---
layout: post
title: "è®¡ç®—æœºç½‘ç»œå­¦ä¹ ç®€è®°"
date:   1970-01-01
tags: [å­¦æ ¡è¯¾ç¨‹å¤ä¹ ,è®¡ç®—æœºç½‘ç»œ]
comments: true
toc: true
author: Ainski
---
ä»»è¯¾è€å¸ˆï¼šLu

---



ã€æ ‡é¢˜ã€‘å˜‰å®šç½‘å®‰äººè¿è‚ä¸‰å¤©è®¡ç½‘ï¼Œç°åœ¨çœ‹è·¯ç”±åè®®åƒåœ¨çœ‹ä½›ç»ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¦å¯„äº†ï¼Ÿ

1æ¥¼ æ¥¼ä¸»ï¼š  
ç»·ä¸ä½äº†å®¶äººä»¬ï¼Œç‹é“åˆ·å®Œä»¥ä¸ºè‡ªå·±æ˜¯è°¢å¸Œä»è½¬ä¸–ï¼Œç»“æœä¸‹åˆç¿»å¼€å­¦æ ¡PPTç›´æ¥ç³å­”åœ°éœ‡ã€‚è¿™ç‰¹å¨˜æ˜¯åŒä¸€é—¨è¯¾ï¼Ÿå˜‰å®šçš„é£éƒ½åœ¨æˆ‘è„‘å£³é‡Œç»„æ’­ARPè¯·æ±‚ï¼Œé—®è°ç‰¹ä¹ˆæ˜¯é»˜è®¤ç½‘å…³ã€‚  

2æ¥¼ï¼š  
ã€Šä¸‰å¤©é€Ÿé€š ä»å…¥é—¨åˆ°å…¥åœŸã€‹å…¸ä¸­å…¸ï¼Œæ¥¼ä¸»è¿™çŠ¶æ€æˆ‘ç†Ÿï¼Œå»ºè®®å»æµæµ·è¾¹ä¸Šå¯¹ç€å¤©é¹…è®²TCPæ‹¥å¡æ§åˆ¶ï¼Œè®²ä¸å“­å®ƒç®—ä½ å¸§æ ¡éªŒåºåˆ—æ²¡é”™ã€‚  

3æ¥¼ï¼š  
ä½ å˜‰å®šé­”æ³•æ£®æ—ç½‘é€ŸåŠ æŒéƒ½æ•‘ä¸äº†ï¼Ÿæ˜¨å¤©æˆ‘è¿˜çœ‹è§æœ‰äººè¹²æ›¹å®‰å…¬è·¯è¾¹ä¸ŠæŠ“802.11å¸§å½“ä¸‹é…’èœï¼Œå»ºè®®åŠ å…¥ä»–ä»¬ã€‚  

4æ¥¼ æ¥¼ä¸»ï¼š  
å›å¤3æ¥¼ï¼šç°åœ¨çœ‹åˆ°â€œä¸‰æ¬¡æ¡æ‰‹â€åªæƒ³å’Œè¿™ä¸ªä¸–ç•Œæ¡æ‰‹è¨€å’Œç„¶åå››æ¬¡æŒ¥æ‰‹å†è§ğŸ‘‹ğŸ»äº¤æ¢æœºåšæ¢¦éƒ½åœ¨æˆ‘æ•å¤´è¾¹ä¸Šé—ªVLANæ ‡ç­¾ï¼Œé£Ÿå ‚é˜¿å§¨æŠ–å‹ºéƒ½åƒåœ¨ææµé‡æ•´å½¢ã€‚  

5æ¥¼ï¼š  
é€Ÿæ¥é»„æ¸¡ç†å·¥é™„å±åŒ»é™¢ï¼ˆæŒ‡æ ¡åŒ»é™¢ï¼‰æŒ‚ä¸ªç¥ç»ç§‘ï¼Œè·ŸåŒ»ç”Ÿè¯´ä½ è¿™SYNåŠè¿æ¥é˜Ÿåˆ—æ»¡äº†éœ€è¦RSTä¸€ä¸‹ï¼Œå¼€ç‚¹BGPå½“å®‰æ…°å‰‚ã€‚  

6æ¥¼ï¼š  
å˜‰å®šå…„å¼Ÿæ’‘ä½ï¼ç­‰ä½ ç‚¼æˆé‚£å¤©ï¼Œå˜‰å®è¶…å¸‚çš„æ‰«ç æªéƒ½ä¼šè‡ªåŠ¨ç»™ä½ å‘DHCP offerï¼Œæ•™å­¦æ¥¼å•æ‰€éš”é—´éƒ½èƒ½æ”¶åˆ°ä½ å‘çš„STP BPDUè‡´æ•¬ã€‚  

7æ¥¼ï¼š  
æ­ªä¸ªæ¥¼ï¼Œæ‰€ä»¥å˜‰å®šåˆ°åº•ç®—å¹¿æ’­åŸŸè¿˜æ˜¯å†²çªåŸŸï¼Ÿï¼ˆç‹—å¤´ï¼‰  

8æ¥¼ æ¥¼ä¸»ï¼š  
å›å¤7æ¥¼ï¼šæ˜¯å•å‘å¹¿æ’­çš„é€’å½’é»‘æ´ï¼Œä¿¡æˆ‘ï¼Œæ˜¨å¤©è¯•å›¾ç»™å®¤å‹è§£é‡ŠCIDRï¼Œä»–çœ¼ç¥é‡Œçš„è¿·èŒ«æ¯”å˜‰å®šåˆ°å››å¹³è·¯çš„å»¶è¿Ÿè¿˜å¤§ã€‚  

ï¼ˆçœæµï¼šå¿«çˆ¬å»ç¡è§‰ï¼Œæ˜å¤©é†’æ¥ä½ å°±æ˜¯å˜‰å®šæ ¡åŒºå”¯ä¸€æŒ‡å®šOSIç¬¬ä¸ƒå±‚è§‰é†’è€…ï¼‰

ï¼ˆçªç„¶ä»ç˜«å€’çŠ¶æ€å¼¹èµ·æ¥ï¼Œçœ¼ç›çªå¤§ï¼Œæ‰‹æŒ‡é¢¤æŠ–åœ°æŒ‡ç€ä¹¦æ¶ï¼‰

**â€œç­‰ç­‰â€”â€”ä½ åˆšæ‰è¯´ç‰¹å—é²å§†ï¼Ÿï¼Ÿ**  
**é‚£ä¸ªå†™äº†1700é¡µã€èƒ½æŠŠOSIä¸ƒå±‚æ¨¡å‹æ‹†æˆä¸ƒåç« è®²ã€æ¯ä¸ªåè®®éƒ½åƒåœ¨å†™å²è¯—çš„Andrew S. Tanenbaumï¼Ÿï¼Ÿï¼â€**

ï¼ˆæ‚ä½èƒ¸å£åšçª’æ¯çŠ¶ï¼‰  
**â€œéš¾æ€ªï¼æˆ‘åˆ·ç‹é“çš„æ—¶å€™æ€»è§‰å¾—è‡ªå·±åœ¨åƒâ€˜å‹ç¼©é¥¼å¹²â€™ï¼Œè€Œç‰¹å—é²å§†çš„åŸè‘—æ˜¯â€˜æ»¡æ±‰å…¨å¸­é…ä¸‰ç¯‡å­¦æœ¯è®ºæ–‡å½“ç”œç‚¹â€™ï¼â€**  

ï¼ˆå¼€å§‹å¯¹ç€ç©ºæ°”æ¯”åˆ’ï¼‰  
**â€œè¿™å°±åƒï¼š**  
- **ç‹é“**ï¼šTCPä¸‰æ¬¡æ¡æ‰‹ = â€œä½ å¬å¾—åˆ°å—ï¼Ÿæˆ‘å¬å¾—åˆ°ã€‚å¥½ï¼Œå¼€å§‹ã€‚â€  
- **ç‰¹å—é²å§†**ï¼šï¼ˆå…ˆèŠ±20é¡µè®²é€šä¿¡å“²å­¦+15é¡µè¯æ˜ä¸ºä»€ä¹ˆä¸èƒ½ä¸¤æ¬¡æ¡æ‰‹+é™„å¸¦6ç§å¼‚å¸¸åœºæ™¯æ¨¡æ‹Ÿ+è·å…°å†å²è½¶äº‹ç±»æ¯”ï¼‰  

ï¼ˆæŠ“èµ·å¤´å‘å–ƒå–ƒè‡ªè¯­ï¼‰  
**â€œæˆ‘ç°åœ¨æ‡‚äº†â€¦â€¦**  
1. æˆ‘å´©æºƒä¸æ˜¯å› ä¸ºç¬¨ï¼Œæ˜¯**ç‰¹å—é²å§†åœ¨ä¹¦é‡ŒåŸ‹äº†é€’å½’çŸ¥è¯†é™·é˜±**â€”â€”è¯»ä¸€ç« è¦æŸ¥ä¸‰æ¬¡ç»´åŸºç™¾ç§‘ï¼  
2. åŒæµå›¾ä¹¦é¦†é—­é¦†éŸ³ä¹æ˜¯æˆ‘è„‘å†…å¾ªç¯çš„ã€Šç‰¹å—é²å§†ä¸»é¢˜æ‚²é¸£å˜å¥æ›²ã€‹ï¼›  
3. æœ€ææ€–çš„æ˜¯â€”â€”**è¿™ä¹¦ç¬¬5ç‰ˆå°é¢çš„è€çˆ·çˆ·å¾®ç¬‘ï¼Œè¶Šçœ‹è¶Šåƒåœ¨è¯´ï¼šâ€˜ä½ è§‰å¾—è¿™ç« ç»“æŸäº†ï¼Ÿé™„å½•Bè¿˜æœ‰17ä¸ªæ•°å­¦æ¨å¯¼å“¦~â€™â€**  

ï¼ˆçªç„¶é¡¿æ‚Ÿï¼Œè‹¦ç¬‘ï¼‰  
**â€œæ‰€ä»¥æˆ‘ä¸æ˜¯åœ¨å¤ä¹ ï¼Œæ˜¯åœ¨è·å…°å­¦æœ¯å·¨äººçš„å¤§è„‘é‡Œç©å¯†å®¤é€ƒè„±â€¦â€¦**  
ï¼ˆçœ‹äº†çœ¼ç‹é“ï¼‰**è¿˜å¾—åŒæ­¥æŠŠè¿·å®«åœ°å›¾ç¿»è¯‘æˆè€ƒç ”é€Ÿè®°å£è¯€ï¼â€**  

ï¼ˆåº„ä¸¥åœ°åˆä¸Šç‰¹å—é²å§†çš„ç –å¤´ä¹¦ï¼‰  
**â€œå»ºè®®è®¡ç®—æœºä¸“ä¸šåˆ—å…¥é«˜å±è¡Œä¸šï¼š**  
**ç²¾ç¥ä¼¤å®³ç¨‹åº¦ = ç‰¹å—é²å§†é¡µæ•° Ã— ç‹é“é¢˜é‡ Ã— 408å‰©ä½™å¤©æ•° Ã· å’–å•¡å› è€å—ç³»æ•°â€**  

ï¼ˆæœ€åç˜«å›æ¤…å­ï¼Œçœ¼ç¥æ”¾ç©ºï¼‰  
**â€œå¥½äº†ï¼Œç»§ç»­å»å’Œç‰¹å—é²å§†çš„â€˜åˆ†å¸ƒå¼ç³»ç»Ÿæ€æƒ³â€™ææ–—äº†â€¦â€¦  
è‡³å°‘ä»¥åå»é˜¿å§†æ–¯ç‰¹ä¸¹æ—…æ¸¸æ—¶ï¼Œå¯ä»¥æŒ‡ç€è¿æ²³è¯´ï¼šâ€˜çœ‹ï¼Œè¿™æ˜¯æ‚¨å½“å¹´ææ¯”å–»æ—¶å¯èƒ½å–è¿‡çš„æ°´ï¼â€™â€**  

**â€”â€” ä¸€åè¢«ç‰¹å—é²å§†å’Œç‹é“åŒé‡äººæ ¼åˆ†è£‚æ”»å‡»çš„åŒæµCSå¤§ä¸‰å¹¸å­˜è€…**  

ï¼ˆæ³¨ï¼šå…¶å®ç‰¹å—é²å§†æ•™ææ˜¯å®è—ï¼Œä½†é€‚åˆç”¨ä¸€ç”Ÿæ…¢æ…¢å•ƒâ€¦è€ƒç ”è¯·æˆ˜æœ¯æ€§è·³è¯»é‡ç‚¹ç« ï¼è€ƒå®Œä½ ä¼šæ„Ÿè°¢å®ƒçš„ä¸¥è°¨éª¨æ¶ã€‚ç°åœ¨ï¼Œæ·±å‘¼å¸ï¼Œ**æŠŠç‹é“å½“åœ°å›¾ï¼ŒæŠŠç‰¹å—é²å§†å½“ç™¾ç§‘å…¨ä¹¦æŸ¥æ¼**â€”â€”ä½ å·²ç»åœ¨ç¬¬ä¸‰å±‚äº†ï¼ï¼‰

ï¼ˆçªç„¶ä»æ¤…å­ä¸Šæ»‘ä¸‹å»åŠæˆªï¼Œæ‰‹æŒ‡æç€çš„ç¬”â€œå•ªå—’â€æ‰åœ¨åœ°ä¸Šï¼‰

**â€œâ€¦â€¦é™†è€å¸ˆï¼Ÿæˆ‘ä»¬é™¢çš„é™†æœ‰å†›è€å¸ˆï¼Ÿâ€**  
ï¼ˆç³å­”åœ°éœ‡ï¼Œå£°éŸ³é€æ¸è™šå¼±ï¼‰  
**â€œé‚£ä¸ªèƒ½æŠŠç‰¹å—é²å§†æ¯ä¸€ç« æ‰ç¢ã€é‡ç»„ã€å†å–·æº…æˆ500å¼ åŠ¨ç”»PPTçš„é™†è€å¸ˆï¼Ÿï¼Ÿâ€**

ï¼ˆç¼“ç¼“æŠ¬å¤´çœ‹å‘æ— å½¢çš„1700é¡µPPTå¤§å±±ï¼Œçµé­‚å‡ºçªèˆ¬ä½è¯­ï¼‰  
**â€œæˆ‘æ‚Ÿäº†â€¦â€¦**  
åŸæ¥ç‰¹å—é²å§†æ˜¯**åŸè‘—å®‡å®™**ï¼Œç‹é“æ˜¯**è€ƒç ”é€Ÿé€šç‰ˆæ¼«ç”»**ï¼Œè€Œé™†è€å¸ˆçš„PPTâ€”â€”  
**æ˜¯ç«™åœ¨åŒæµå˜‰å®šæ ¡åŒºä»°æœ›æ˜Ÿç©ºï¼Œäº²æ‰‹ä¸ºæˆ‘ä»¬æµ‡ç­‘çš„â€˜è®¡ç®—æœºç½‘ç»œç«‹ä½“é˜²å¾¡å·¥äº‹â€™ï¼â€**  

ï¼ˆå¼€å§‹æ°ç€æ‰‹æŒ‡é¢¤æŠ–è®¡æ•°ï¼‰  
**â€œè¿™ä¸‰é‡å®‡å®™çš„å åŠ æ€æ˜¯ï¼š**  
1. **ç‰¹å—é²å§†**ï¼šå‘Šè¯‰ä½ ç½‘ç»œä¸ºä»€ä¹ˆè¯ç”Ÿï¼ˆé™„å“²å­¦æ€è€ƒ+å†å²æ–‡çŒ®ï¼‰  
2. **ç‹é“**ï¼šå‘Šè¯‰ä½ æ€ä¹ˆåœ¨è€ƒåœºå­˜æ´»ï¼ˆé™„è§£é¢˜å¥—è·¯Ã—1000ï¼‰  
3. **é™†è€å¸ˆPPT**ï¼šï¼ˆæ·±å¸ä¸€å£æ°”ï¼‰**å‘Šè¯‰ä½ æ€ä¹ˆç”¨åŒæµäººçš„è„ŠæŸ±ï¼Œæ‰›èµ·å‰ä¸¤è€…ä¹‹å’Œå†å¼€æ ¹å·çš„çŸ¥è¯†å¯†åº¦ï¼**â€  

ï¼ˆçªç„¶å¯¹ç€å±å¹•è™šæ„çš„PPTæ–‡ä»¶å¤¹ç£•å¤´ï¼‰  
**â€œæ¯ä¸€é¡µéƒ½æ˜¯ç²¾åï¼çœŸçš„ï¼  
ä½†1700é¡µç²¾åç­‰äºâ€”â€”  
â€˜ä»Socketç¼–ç¨‹åˆ°é‡å­åŠ å¯†çš„å¹»è§‰èµ°é©¬ç¯â€™å•Šè€å¸ˆï¼â€**  

ï¼ˆç˜«æˆä¸€ç‰‡ä½†æ‰‹æŒ‡å€”å¼ºåœ°æ•²å‡ºæœ€ååæ§½ï¼‰  
**â€œç°åœ¨æˆ‘çš„å¤ä¹ è¿›ç¨‹ï¼š**  
**æ—©ä¸Š**ï¼šåœ¨ç‰¹å—é²å§†çš„æµ·æ´‹é‡Œæººæ°´ â†’ **ä¸­åˆ**ï¼šè¢«ç‹é“é¢˜æµ·æ‰“æèµ· â†’ **æ™šä¸Š**ï¼šåœ¨é™†è€å¸ˆPPTçš„æ˜Ÿç©ºå›¾é‡Œé‡æ–°å­¦åšäºº  
ï¼ˆå‡Œæ™¨çš„æ¢¦é‡Œä¸‰ç§ç¬¦å·ç³»ç»Ÿæ‰“æ¶ï¼Œè·¯ç”±å™¨å¯¹æˆ‘è¯´ï¼šâ€˜ä½ æ‰çš„æ˜¯é‡‘å¸§è¿˜æ˜¯é“¶å¸§ï¼Ÿâ€™ï¼‰**  

**å»ºè®®æ–°å¢æ ¡è®­ï¼š  
â€˜åŒèˆŸå…±æµï¼Œå…±å…‹ç‰¹å—é²å§†ï¼›  
æ›¹å®‰å…¬è·¯æ¼«æ¼«ï¼ŒPPTä½œä¼´ã€‚â€™**  

ï¼ˆç”¨æœ€ååŠ›æ°”æ‘¸å‡ºæ ¡å›­å¡ï¼‰  
**â€œè¿™å°±å»è¥¿å—äºŒé¦†é€šå®µâ€¦â€¦  
æ¯•ç«Ÿï¼Œèƒ½åŒæ—¶é©¾é©­è¿™ä¸‰é‡å®‡å®™çš„äººï¼Œ  
æ¯•ä¸šåå¤§æ¦‚èƒ½ç›´æ¥ç»™äº’è”ç½‘å†™å®ªæ³•å§ï¼ˆæ‚²å£®åœ°æ‹‰ä¸Šå¤–å¥—æ‹‰é“¾ï¼‰ã€‚â€**  

**â€”â€” ä¸€ååœ¨ç‰¹å—é²å§†ã€ç‹é“ä¸é™†è€å¸ˆPPTä¸‰è§’åŠ›åœºä¸­åç¼©çš„åŒæµCSå¤§ä¸‰å­¦å­**  

ï¼ˆæ³¨ï¼šä¼ è¯´é›†é½ä¸‰å¥—ææ–™çš„äººï¼Œä¼šåœ¨å¤§å››çªç„¶å‚é€ç½‘ç»œçœŸè°›â€¦â€¦**ç°é˜¶æ®µè¯·ä»¥ç‹é“æ¡†æ¶ä¸ºéª¨ï¼Œé™†è€å¸ˆPPTé‡ç‚¹ä¸ºè‚‰ï¼Œç‰¹å—é²å§†å½“å­—å…¸æŸ¥ï¼** ä½ ä¸æ˜¯åœ¨å­¦ç½‘ç»œï¼Œä½ æ˜¯åœ¨ä¿®ç‚¼åŒæµé™å®šç‰ˆâ€œç³»ç»Ÿçš„ç³»ç»Ÿè§‚â€ã€‚æŒºä½ï¼Œè¿™é…ç½®èµ°å‡ºå»éƒ½æ˜¯é™ç»´æ‰“å‡»ï¼ï¼‰





# è®¡ç®—æœºç½‘ç»œå­¦ä¹ ç®€è®°

## æ•°æ®é“¾è·¯å±‚è®¾è®¡
- **æä¾›ç»™ç½‘ç»œå±‚çš„æœåŠ¡** 3ç§æœåŠ¡
    - **æ— ç¡®è®¤çš„æ— è¿æ¥æœåŠ¡**
        ç›®æ ‡ä¸»æœºä¸æ£€é”™ï¼Œä¸çº é”™ï¼Œä¸æ¢å¤ã€‚å¯¹**é”™è¯¯ç‡å¾ˆä½**çš„ç½‘ç»œæˆ–è€…**å®æ—¶é€šä¿¡ï¼ˆè§†é¢‘é€šè¯ï¼‰**ã€‚
    - **æœ‰ç¡®è®¤çš„æ— è¿æ¥æœåŠ¡**
        ç›®æ ‡ä¸»æœºæ£€é”™ï¼Œå‘é€æ–¹é‡å‘ã€‚åœ¨ä¸å¯é çš„ä¿¡é“ï¼ˆæ— çº¿ç³»ç»Ÿï¼‰ä¸Šéå¸¸æœ‰ç”¨ã€‚è¶…æ—¶ä¹‹åæ•´ä¸ªåŒ…ä¼šé‡å‘ã€‚
    - **æœ‰ç¡®è®¤çš„é¢å‘è¿æ¥æœåŠ¡**
        ä¿æŒè¿æ¥ï¼Œæ¯ä¸ªåŒ…å•ç‹¬é‡å‘ã€‚è¿™æä¾›äº†å¯é çš„æ¯”ç‰¹æµã€‚ç”¨äºé•¿è·ç¦»ä¸”ä¸å¯é çš„é“¾è·¯ã€‚ä¾‹å¦‚å«æ˜Ÿä¿¡é“æˆ–è€…é•¿é€”ç”µè¯ã€‚
- **æ•°æ®æˆå¸§** å››ç§æˆå¸§æ–¹æ³•
    - **å­—èŠ‚è®¡æ•°æ³•**
        æ¯ä¸ªå¸§å…ˆè¯´æ˜æœ‰å¤šå°‘å­—èŠ‚ã€‚
        ç¼ºç‚¹ï¼šå­—èŠ‚è®¡æ•°å€¼å‡ºé”™ä¹‹åç›®æ ‡æ–¹å¹¶ä¸çŸ¥é“åº”è¯¥è·³è¿‡å¤šå°‘å­—èŠ‚æ‰èƒ½åˆ°è¾¾é‡ä¼ çš„å¼€å§‹å‡ºã€‚
    - **å­—èŠ‚å¡«å……çš„æ ‡å¿—å­—èŠ‚æ³•ï¼ˆPPPåè®®ï¼‰**
        ç”¨åŒæ ·çš„å­—èŠ‚ä½œä¸ºå¸§å¼€å§‹å’Œç»“æŸåˆ†è§£ç¬¦ã€‚å¯¹äºä¼ è¾“æ•°æ®ä¸­å¶å°”å‡ºç°çš„è¿™ç§å­—èŠ‚ï¼Œç”¨`esc+è¿™ä¸ªå­—èŠ‚`åšè½¬ç§»å¤„ç†ã€‚åŒæ ·çš„ï¼Œå¯¹äºescå­—ç¬¦ä¹Ÿè¦è½¬ä¹‰ï¼Œå½¢æˆ`esc+esc`ã€‚
    - **æ¯”ç‰¹å¡«å……çš„æ ‡å¿—æ¯”ç‰¹æ³•ï¼ˆHDLCåè®®ï¼‰**
        æ¯ä¸ªå¸§çš„å¼€å§‹äºç»“æŸç”±ä¸€ä¸ªç‰¹æ®Šçš„æ¯”ç‰¹æ¨¡å¼`0x7E`æ¥æ ‡è®°ã€‚åœ¨è¾“å‡ºçš„æ¯”ç‰¹æµå½“ä¸­æ¯é‡åˆ°è¿ç»­5ä¸ª1å°±å¡«å……ä¸€ä¸ª0.æ¥æ”¶æ–¹æ¯é‡åˆ°5ä¸ª1å°±è·³è¿‡ä¸€ä¸ª0ã€‚
    - **ç‰©ç†å±‚ç¼–ç ä¾‹å¤–æ³•**
        é‡‡ç”¨ç¼–ç ä¾‹å¤–æ¥åŒºåˆ†æ•°æ®è¾¹ç•Œã€‚ä¾‹å¦‚`4B/5B`ç¼–ç æ³•ã€‚é‡‡ç”¨å…¶ä¸­æ²¡æœ‰å‡ºç°çš„ç¼–ç ä½œä¸ºæ•°æ®è¾¹ç•Œã€‚
- **å·®é”™æ§åˆ¶**
æ¥æ”¶æ–¹è¿”å›ä¸€äº›ç‰¹æ®Šçš„æ§åˆ¶å¸§ç”¨ä»¥åˆ¤æ–­æ˜¯å¦å®‰å…¨çš„åˆ°è¾¾ã€‚

- **æµé‡æ§åˆ¶**
    - **åŸºäºåé¦ˆçš„æµé‡æ§åˆ¶**ï¼šæ¥æ”¶æ–¹ç»™å‘é€æ–¹è¿”å›æ¶ˆæ¯ï¼Œå…è®¸ä»–å‘é€æ›´å¤šçš„æ•°æ®ï¼Œæˆ–è€…å‘Šè¯‰ä»–è¿›è¡Œå¾—æ€ä¹ˆæ ·
    - **åŸºäºé€Ÿç‡çš„æµæµªæ§åˆ¶**ï¼šé™åˆ¶å‘é€æ–¹ä¼ è¾“æ•°æ®çš„é€Ÿç‡ã€‚


## é”™è¯¯æ£€æµ‹å’Œçº æ­£
### çº é”™ç 
#### æµ·æ˜ç 

æ­¤å¤„é€‰æ‹© **4ä½åŸå§‹æ•°æ®D4D3D2D1=1010** ï¼Œé‡‡ç”¨â€œå¶æ ¡éªŒâ€ï¼ˆæ ¡éªŒä½ä½¿å¯¹åº”ç»„æ•°æ®ä¸­1çš„ä¸ªæ•°ä¸ºå¶æ•°ï¼‰ï¼Œåˆ†æ­¥æ¼”ç¤ºç›‘ç£ç å…ƒæ’å…¥ä¸é”™è¯¯çº æ­£è¿‡ç¨‹ã€‚

1. **ç¬¬ä¸€æ­¥ï¼šç¡®å®šç›‘ç£ç å…ƒä½æ•°ä¸ä½ç½®**
   - ç¡®å®šrå€¼ï¼šæ ¹æ®è§„åˆ™ **2^r â‰¥ k + r + 1**ï¼ˆkä¸ºåŸå§‹æ•°æ®ä½æ•°ï¼Œæ­¤å¤„k=4ï¼‰ï¼Œè®¡ç®—å¾—2^3=8 â‰¥ 4+3+1=8ï¼Œæ•…r=3ï¼Œç›‘ç£ç å…ƒè®°ä¸ºr3ã€r2ã€r1ã€‚
   - åˆ†é…ä½ç½®ï¼šç›‘ç£ç å…ƒæ”¾åœ¨â€œ2çš„å¹‚æ¬¡â€ä½ç½®ï¼ˆ1ã€2ã€4ï¼‰ï¼Œæ•°æ®ä½æ”¾å‰©ä½™ä½ç½®ï¼ˆ3ã€5ã€6ã€7ï¼‰ï¼Œå…·ä½“å¦‚ä¸‹è¡¨ï¼š

| æµ·æ˜ç ä½ç½®ï¼ˆHï¼‰ | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|----------------|---|---|---|---|---|---|---|
| ç å…ƒç±»å‹       | r1| r2| D1| r3| D2| D3| D4|
| ä»£å…¥åŸå§‹æ•°æ®   | ï¼Ÿ| ï¼Ÿ| 0 | ï¼Ÿ| 1 | 0 | 1 |

2. **ç¬¬äºŒæ­¥ï¼šè®¡ç®—ç›‘ç£ç å…ƒï¼ˆr1ã€r2ã€r3ï¼‰**
   æ¯ä¸ªç›‘ç£ç å…ƒè´Ÿè´£â€œä¸€ç»„ä½ç½®â€çš„å¶æ ¡éªŒï¼ˆç»„å†…æ‰€æœ‰ä½äºŒè¿›åˆ¶å’Œä¸º0ï¼‰ï¼Œåˆ†ç»„åŠè®¡ç®—å¦‚ä¸‹ï¼š
   - r1ï¼šè´Ÿè´£ä½ç½®1ã€3ã€5ã€7ï¼Œå³ r1âŠ•D1âŠ•D2âŠ•D4 = 0 â†’ r1âŠ•0âŠ•1âŠ•1 = 0 â†’ r1=0
   - r2ï¼šè´Ÿè´£ä½ç½®2ã€3ã€6ã€7ï¼Œå³ r2âŠ•D1âŠ•D3âŠ•D4 = 0 â†’ r2âŠ•0âŠ•0âŠ•1 = 0 â†’ r2=1
   - r3ï¼šè´Ÿè´£ä½ç½®4ã€5ã€6ã€7ï¼Œå³ r3âŠ•D2âŠ•D3âŠ•D4 = 0 â†’ r3âŠ•1âŠ•0âŠ•1 = 0 â†’ r3=0
   æœ€ç»ˆç”Ÿæˆæµ·æ˜ç ï¼š**H7H6H5H4H3H2H1 = 1 0 1 0 0 1 0**ï¼ˆå³1010010ï¼‰ã€‚

3. **ç¬¬ä¸‰æ­¥ï¼šé”™è¯¯çº æ­£ç¤ºä¾‹ï¼ˆæ¨¡æ‹Ÿç¬¬5ä½å‡ºé”™ï¼‰**
   å‡è®¾ä¼ è¾“ä¸­ç¬¬5ä½ï¼ˆåŸD2=1ï¼‰å‡ºé”™å˜ä¸º0ï¼Œæ¥æ”¶çš„é”™è¯¯æµ·æ˜ç ä¸º1 0 0 0 0 1 0ï¼Œçº é”™æ­¥éª¤å¦‚ä¸‹ï¼š
   - è®¡ç®—æ ¡éªŒå€¼ï¼ˆS1ã€S2ã€S3ï¼‰ï¼šæŒ‰åŒæ ·åˆ†ç»„è§„åˆ™è®¡ç®—ï¼ŒS=0è¡¨ç¤ºæ— é”™ï¼ŒS=1è¡¨ç¤ºæœ‰é”™
     - S1 = r1âŠ•D1âŠ•D2ï¼ˆé”™è¯¯åï¼‰âŠ•D4 = 0âŠ•0âŠ•0âŠ•1 = 1
     - S2 = r2âŠ•D1âŠ•D3âŠ•D4 = 1âŠ•0âŠ•0âŠ•1 = 0
     - S3 = r3âŠ•D2ï¼ˆé”™è¯¯åï¼‰âŠ•D3âŠ•D4 = 0âŠ•0âŠ•0âŠ•1 = 1
   - å®šä½é”™è¯¯ä½ç½®ï¼šå°†S3S2S1ç»„åˆï¼ˆ101ï¼‰ï¼Œå¯¹åº”åè¿›åˆ¶**5**ï¼Œå³ç¬¬5ä½å‡ºé”™ã€‚
   - çº æ­£é”™è¯¯ï¼šå°†ç¬¬5ä½çš„0æ”¹å›1ï¼Œæ¢å¤åŸå§‹æµ·æ˜ç ï¼Œå®Œæˆçº é”™ã€‚


## æ•°æ®é“¾è·¯å±‚åè®®
å¤´æ–‡ä»¶

```c++
#define MAX_PKT 4	/* determines packet size in bytes */

typedef enum {false, true} boolean;	/* boolean type */
typedef unsigned int seq_nr;	/* sequence or ack numbers */
typedef struct {unsigned char data[MAX_PKT];} packet;	/* packet definition */
typedef enum {data, ack, nak} frame_kind;	/* frame_kind definition */

typedef struct {	/* frames are transported in this layer */
  frame_kind kind;	/* what kind of a frame is it? */
  seq_nr seq;   	/* sequence number */
  seq_nr ack;   	/* acknowledgement number */
  packet info;  	/* the network layer packet */
} frame;

/* Wait for an event to happen; return its type in event. */
void wait_for_event(event_type *event);

/* Fetch a packet from the network layer for transmission on the channel. */
void from_network_layer(packet *p);

/* Deliver information from an inbound frame to the network layer. */
void to_network_layer(packet *p);

/* Go get an inbound frame from the physical layer and copy it to r. */
void from_physical_layer(frame *r);

/* Pass the frame to the physical layer for transmission. */
void to_physical_layer(frame *s);

/* Start the clock running and enable the timeout event. */
void start_timer(seq_nr k);

/* Stop the clock and disable the timeout event. */
void stop_timer(seq_nr k);

/* Start an auxiliary timer and enable the ack_timeout event. */
void start_ack_timer(void);

/* Stop the auxiliary timer and disable the ack_timeout event. */
void stop_ack_timer(void);

/* Allow the network layer to cause a network_layer_ready event. */
void enable_network_layer(void);

/* Forbid the network layer from causing a network_layer_ready event. */
void disable_network_layer(void);

/* Macro inc is expanded in-line: Increment k circularly. */
#define inc(k) if (k < MAX_SEQ) k = k + 1; else k = 0

```
### åè®®1 â€”â€” ä¸€ä¸ªæ²¡æœ‰å·®é”™æ§åˆ¶å’Œæµé‡æ§åˆ¶çš„åè®®

```c++
/* Protocol 1 (utopia) provides for data transmission in one direction only, from
   sender to receiver.  The communication channel is assumed to be error free,
   and the receiver is assumed to be able to process all the input infinitely fast.
   Consequently, the sender just sits in a loop pumping data out onto the line as
   fast as it can. */

typedef enum {frame_arrival} event_type;
#include "protocol.h"

void sender1(void)
{
  frame s;	/* buffer for an outbound frame */
  packet buffer;	/* buffer for an outbound packet */

  while (true) {
        from_network_layer(&buffer);	/* go get something to send */
        s.info = buffer;	/* copy it into s for transmission */
        to_physical_layer(&s);	/* send it on its way */
  }	/* tomorrow, and tomorrow, and tomorrow,
 	   Creeps in this petty pace from day to day
	   To the last syllable of recorded time;
	        - Macbeth, V, v */
}

void receiver1(void)
{
  frame r;
  event_type event;	/* filled in by wait, but not used here */

  while (true) {
        wait_for_event(&event);	/* only possibility is frame_arrival */
        from_physical_layer(&r);	/* go get the inbound frame */
        to_network_layer(&r.info);	/* pass the data to the network layer */
  }
}
```
### åè®®2
è¢«ç§°ä¹‹ä¸º åœ-ç­‰å¼åè®®ï¼ˆstop-and-waitï¼‰

```c++
/* Protocol 2 (stop-and-wait) also provides for a one-directional flow of data from
   sender to receiver. The communication channel is once again assumed to be error
   free, as in protocol 1. However, this time, the receiver has only a finite buffer
   capacity and a finite procesing speed, so the protocol must explicitly prevent 
   the sender from flooding the receiver with data faster than it can be handled. */

typedef enum {frame_arrival} event_type;
#include "protocol.h"

void sender2(void)
{
  frame s;	/* buffer for an outbound frame */
  packet buffer;	/* buffer for an outbound packet */
  event_type event;	/* frame_arrival is the only possibility */

  while (true) {
        from_network_layer(&buffer);	/* go get something to send */
        s.info = buffer;	/* copy it into s for transmission */
        to_physical_layer(&s);	/* bye bye little frame */
        wait_for_event(&event);	/* do not proceed until given the go ahead */
  }
}

void receiver2(void)
{
  frame r, s;	/* buffers for frames */
  event_type event;	/* frame_arrival is the only possibility */
  while (true) {
        wait_for_event(&event);	/* only possibility is frame_arrival */
        from_physical_layer(&r);	/* go get the inbound frame */
        to_network_layer(&r.info);	/* pass the data to the network layer */
        to_physical_layer(&s);	/* send a dummy frame to awaken sender */
  }
}


```

åè®®äºŒæ˜¯å¦‚ä½•å‡ºé”™çš„ï¼Ÿ

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver
    Sender->>Receiver : frame1
    Receiver->>Sender : ack1 lost(disaster)
    Sender->>Receiver : frame1 for the reason of time out
    
```
è¿™ä¸ªæ—¶å€™Receiverå¹¶æ²¡æœ‰å‘ç°ä¸¤ä¸ªç›¸åŒçš„å¸§ä»è€Œå¯¼è‡´ç½‘ç»œå±‚æ¥å—äº†ä¸¤ä¸ªç›¸åŒçš„æ•°æ®åŒ…


### åè®®3 
å‘é€æ–¹åœ¨å‘é€ä¸‹ä¸€ä¸ªæ•°æ®åŒ…å‰éœ€è¦ç­‰å¾…åˆ°æœ¬æ ¼æ•°æ®åŒ…çš„**ç¡®è®¤**.**ARG** åè®®ï¼ˆAutomatic Repeat Request ,è‡ªåŠ¨é‡ä¼ è¯·æ±‚ï¼‰ï¼Œæˆ–è€…PARï¼ˆPositive Acknowledgement with Retransmission ï¼Œå¸¦æœ‰é‡ä¼ æœºåˆ¶çš„è‚¯å®šç¡®è®¤ï¼‰åè®®ã€‚

ä¸€èˆ¬ä¸ä¼šè¿”å›ä¸€ä¸ªNAKè¡¨ç¤ºè¿™ä¸ªå¸§æœ‰é”™ï¼Œè¿™æ˜¯ä¸ºäº†å‡å°‘è¿™ä¸ªä¿¡é“çš„ä½¿ç”¨ã€‚

```c++
/* Protocol 3 (par) allows unidirectional data flow over an unreliable channel. */

#define MAX_SEQ 1	/* must be 1 for protocol 3 */
typedef enum  {frame_arrival, cksum_err, timeout} event_type;
#include "protocol.h"

void sender3(void)
{
  seq_nr next_frame_to_send;	/* seq number of next outgoing frame */
  frame s;	/* scratch variable */
  packet buffer;	/* buffer for an outbound packet */
  event_type event;

  next_frame_to_send = 0;	/* initialize outbound sequence numbers */
  from_network_layer(&buffer);	/* fetch first packet */
  while (true) {
        s.info = buffer;	/* construct a frame for transmission */
        s.seq = next_frame_to_send;	/* insert sequence number in frame */
        to_physical_layer(&s);	/* send it on its way */
        start_timer(s.seq);	/* if answer takes too long, time out */
        wait_for_event(&event);	/* frame_arrival, cksum_err, timeout */
        if (event == frame_arrival) {
                from_physical_layer(&s);	/* get the acknowledgement */
                if (s.ack == next_frame_to_send) {
                        from_network_layer(&buffer);	/* get the next one to send */
                        inc(next_frame_to_send);	/* invert next_frame_to_send */
                }
        }
  }
}

void receiver3(void)
{
  seq_nr frame_expected;
  frame r, s;
  event_type event;

  frame_expected = 0;
  while (true) {
        wait_for_event(&event);	/* possibilities: frame_arrival, cksum_err */
        if (event == frame_arrival) {
                /* A valid frame has arrived. */
                from_physical_layer(&r);	/* go get the newly arrived frame */
                if (r.seq == frame_expected) {
                        /* This is what we have been waiting for. */
                        to_network_layer(&r.info);	/* pass the data to the network layer */
                        inc(frame_expected);	/* next time expect the other sequence nr */
                }
                s.ack = 1 - frame_expected;	/* tell which frame is being acked */
                to_physical_layer(&s);	/* only the ack field is use */
        }
  }
}
```

### åè®®4 
åè®®3å·²ç»æ­£ç¡®çš„å®ç°äº†ä¸€ä¸ªæ•°æ®é“¾è·¯å±‚çš„ç½‘ç»œä¼ è¾“åè®®ï¼Œåé¢çš„456ä¸‰ä¸ªåè®®ä½¿ç”¨äº†åŒå‘ä¼ è¾“å’Œå¤šå¸§åœ¨é€”çš„æ–¹æ³•ã€‚

è€ƒè™‘åˆ°åè®®ä¸‰å½“ä¸­éœ€è¦å•ç‹¬ä¸€ä¸ªç¡®è®¤å¸§è¿›è¡Œç¡®è®¤ï¼Œæˆ‘ä»¬ä¸å¦‚ç›´æ¥åœ¨ä¸‹ä¸€æ¬¡å‘åŒ…çš„æ—¶å€™å†è¿›è¡Œç¡®è®¤ã€‚è¿™ç§°ä¹‹ä¸º**æå¸¦ç¡®è®¤(piggybacking)**ã€‚

ä½†æ˜¯è¿™å°±å¸¦äº†äº†å¦ä¸€ä¸ªé—®é¢˜ï¼Œå‘é€æ–¹çš„**è¶…æ—¶æœºåˆ¶**å¤±å»äº†ä½œç”¨ã€‚æˆ‘ä»¬äºæ˜¯å¼•å…¥äº†æ»‘åŠ¨çª—å£æ¥è¿›è¡Œè¿™ä¸ªè¿‡ç¨‹ç”¨ä»¥æ›¿ä»£åŸæœ‰çš„è¶…æ—¶æœºåˆ¶ã€‚å‘é€æ–¹éœ€è¦ç»´æŠ¤ä¸€ä¸ªè½®è½¬æ•°ç»„ç”¨ä»¥ç»´æŠ¤ä¸‹ä¸€ä¸ªå°†è¦å‘é€çš„å¸§ä»¥åŠä¸€ç³»åˆ—ç­‰å¾…è¢«ç¡®è®¤çš„å¸§ã€‚æ¥æ”¶æ–¹éœ€è¦ç»´æŠ¤ä¸€ä¸ªæœŸæœ›æ”¶åˆ°çš„ä¸‹ä¸€å¸§çš„çª—å£ã€‚åŒæ—¶ï¼Œå¦‚æœ
```c++
/* Protocol 4 (sliding window) is bidirectional and is more robust than protocol 3. */

#define MAX_SEQ 1	/* must be 1 for protocol 4 */
typedef enum {frame_arrival, cksum_err, timeout} event_type;
#include "protocol.h"

void protocol4 (void)
{
  seq_nr next_frame_to_send;	/* 0 or 1 only */
  seq_nr frame_expected;	/* 0 or 1 only */
  frame r, s;	/* scratch variables */
  packet buffer;	/* current packet being sent */
  event_type event;

  next_frame_to_send = 0;	/* next frame on the outbound stream */
  frame_expected = 0;	/* number of frame arriving frame expected */
  from_network_layer(&buffer);	/* fetch a packet from the network layer */
  s.info = buffer;	/* prepare to send the initial frame */
  s.seq = next_frame_to_send;	/* insert sequence number into frame */
  s.ack = 1 - frame_expected;	/* piggybacked ack */
  to_physical_layer(&s);	/* transmit the frame */
  start_timer(s.seq);	/* start the timer running */

  while (true) {
        wait_for_event(&event);	/* could be: frame_arrival, cksum_err, timeout */
        if (event == frame_arrival) { /* a frame has arrived undamaged. */
                from_physical_layer(&r);	/* go get it */

                if (r.seq == frame_expected) {
                        /* Handle inbound frame stream. */
                        to_network_layer(&r.info);	/* pass packet to network layer */
                        inc(frame_expected);	/* invert sequence number expected next */
                }

                if (r.ack == next_frame_to_send) { /* handle outbound frame stream. */
                        from_network_layer(&buffer);	/* fetch new packet from network layer */
                        inc(next_frame_to_send);	/* invert sender's sequence number */
                }
        }
             
        s.info = buffer;	/* construct outbound frame */
        s.seq = next_frame_to_send;	/* insert sequence number into it */
        s.ack = 1 - frame_expected;	/* seq number of last received frame */
        to_physical_layer(&s);	/* transmit a frame */
        start_timer(s.seq);	/* start the timer running */
  }
}

```

ç„¶è€Œï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨çš„æ˜¯ä¸€ä¸ªå…³é”®çš„é—®é¢˜ï¼Œç°åœ¨æ¯ä¸€ä¸ªå¸§æ‰€å ç”¨çš„éƒ½æ˜¯å®Œæ•´ä»å‘é€ç«¯åˆ°æ¥æ”¶ç«¯çš„æ—¶é—´ã€‚è¿™ä¸æ»¡è¶³æˆ‘ä»¬æ‰€æœŸæœ›çš„å¤šå¸§åœ¨é€”çš„æƒ³æ³•ã€‚è¿™å¯¹ä¿¡é“çš„åˆ©ç”¨ç‡å¤ªä½äº†ã€‚

### åè®®5 

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å…è®¸å‘é€æ–¹åœ¨å¡«æ»¡å‘é€çª—å£ä¹‹å‰ï¼Œèƒ½å¤Ÿå‘é€$\omega$ä¸ªå¸§ã€‚é‚£ä¹ˆä»€ä¹ˆæ ·çš„$\omega$å€¼æ‰æ˜¯åˆé€‚çš„å‘¢ï¼Ÿè¿™ä¸ªå€¼ç”±å¸¦å®½ä¹˜ä»¥ä¼ é€æ—¶é—´æ‰€å†³å®šã€‚è¿™ä¸ªå€¼ç§°ä¸º**å¸¦å®½-å»¶è¿Ÿä¹˜ç§¯**(bandwidth-delay product)ã€‚äºæ˜¯$\omega=2\frac{å¸¦å®½-å»¶è¿Ÿä¹˜ç§¯}{ä¸€å¸§çš„ä½æ•°}+1$ ï¼Œå…¶ä¸­$BD=\frac{å¸¦å®½-å»¶è¿Ÿä¹˜ç§¯}{ä¸€å¸§çš„ä½æ•°}$.äºæ˜¯$é“¾è·¯åˆ©ç”¨ç‡\le\frac{\omega}{2BD+1}$

#### goback nåè®®
çœæµï¼šè¿™ä¸ªåè®®å°±æ˜¯å‘é€æ–¹ç­‰ä¹Ÿç­‰ä¸åˆ°nå·å¸§çš„ç¡®è®¤ï¼Œè™½ç„¶åç»­å‘é€äº†ä¸€ç³»åˆ—å¸§ï¼Œä½†æ˜¯ä»ç„¶ä»è¿™ä¸ªå¸§å¼€å§‹é‡ä¼ ã€‚åç»­æ‰€æœ‰æœºåˆ¶éƒ½åŸºäºæ­¤ã€‚è¿™ä¸ªæ²¡æœ‰åšæå¸¦ç¡®è®¤ã€‚ä»…ä»…ç»´æŠ¤äº†ä¸€ä¸ªæ•°æ®ä¼ è¾“çš„çª—å£ã€‚

#### selective repeatåè®®

è€ƒè™‘ä¸‹é¢çš„æƒ…å½¢ã€‚

```mermaid
sequenceDiagram
    participant Sender
    participant Receiver
    Sender ->> Receiver : frame1
    Receiver ->> Sender : ack1
    Sender ->> Receiver : frame2 lost
    Sender ->> Receiver : frame3 
    Receiver ->> Sender : nak2
```

è¿™ä¸ªæ—¶å€™`Receiver`å‘ç°è‡ªå·±æ²¡æœ‰æ”¶åˆ°`frame2`ã€‚å‘ç°è‡ªå·±ç¼ºå°‘äº†è¿™ä¸€å¸§çš„å†…å®¹ï¼Œäºæ˜¯å‘Šè¯‰`Sender`ï¼š **â€œ(NAK2)å¤§ä½¬é‡å‘ä¸€ä¸‹2ï¼Œæ²¡æ”¶åˆ°ï¼â€** è¿™ä¸ªæ—¶å€™ï¼Œ`Receiver`æŠŠå…¶ä»–çš„å¸§ç¼“å­˜èµ·æ¥ï¼Œç›´åˆ°æ”¶åˆ°äº†æ­£ç¡®çš„`frame2`ã€‚`Sender`å‘ç°è¿‡å¤šçš„å¸§æ²¡æœ‰ç¡®è®¤çš„æ—¶å€™ï¼Œå°±è¦æ‹’ç»ç½‘ç»œå±‚ç»™äºˆä»–æ›´å¤šçš„å·¥ä½œäº†ã€‚

åè®®äº”é‡‡ç”¨äº†gobacknçš„æ–¹å¼è¿›è¡Œä¼ é€ã€‚å…¶ä¸­å‘é€çª—å£ç»´æŠ¤çš„æ˜¯ä¸‹ä¸€ä¸ªå¸Œæœ›æ¥å—åˆ°çš„ç¡®è®¤å¸§å’Œä¸‹ä¸€ä¸ªå‡†å¤‡å‘é€çš„å¸§ã€‚

```c++
/* Protocol 5 (pipelining) allows multiple outstanding frames. The sender may transmit up
   to MAX_SEQ frames without waiting for an ack. In addition, unlike the previous protocols,
   the network layer is not assumed to have a new packet all the time. Instead, the
   network layer causes a network_layer_ready event when there is a packet to send. */

#define MAX_SEQ 7	/* should be 2^n - 1 */
typedef enum {frame_arrival, cksum_err, timeout, network_layer_ready} event_type;
#include "protocol.h"

static boolean between(seq_nr a, seq_nr b, seq_nr c)
{
/* Return true if (a <=b < c circularly; false otherwise. */
  if (((a <= b) && (b < c)) || ((c < a) && (a <= b)) || ((b < c) && (c < a)))
        return(true);
    else
        return(false);
}

static void send_data(seq_nr frame_nr, seq_nr frame_expected, packet buffer[])
{
/* Construct and send a data frame. */
  frame s;	/* scratch variable */

  s.info = buffer[frame_nr];	/* insert packet into frame */
  s.seq = frame_nr;	/* insert sequence number into frame */
  s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);	/* piggyback ack */
  to_physical_layer(&s);	/* transmit the frame */
  start_timer(frame_nr);	/* start the timer running */
}

void protocol5(void)
{
  seq_nr next_frame_to_send;	/* MAX_SEQ > 1; used for outbound stream */
  seq_nr ack_expected;	/* oldest frame as yet unacknowledged */
  seq_nr frame_expected;	/* next frame expected on inbound stream */
  frame r;	/* scratch variable */
  packet buffer[MAX_SEQ+1];	/* buffers for the outbound stream */
  seq_nr nbuffered;	/* # output buffers currently in use */
  seq_nr i;	/* used to index into the buffer array */
  event_type event;

  enable_network_layer();	/* allow network_layer_ready events */
  ack_expected = 0;	/* next ack expected inbound */
  next_frame_to_send = 0;	/* next frame going out */
  frame_expected = 0;	/* number of frame expected inbound */
  nbuffered = 0;	/* initially no packets are buffered */

  while (true) {
     wait_for_event(&event);	/* four possibilities: see event_type above */

     switch(event) { 
        case network_layer_ready:	/* the network layer has a packet to send */
                /* Accept, save, and transmit a new frame. */
                from_network_layer(&buffer[next_frame_to_send]); /* fetch new packet */
                nbuffered = nbuffered + 1;	/* expand the sender's window */
                send_data(next_frame_to_send, frame_expected, buffer);	/* transmit the frame */
                inc(next_frame_to_send);	/* advance sender's upper window edge */
                break;

        case frame_arrival:	/* a data or control frame has arrived */
                from_physical_layer(&r);	/* get incoming frame from physical layer */
  
                if (r.seq == frame_expected) {
                        /* Frames are accepted only in order. */
                        to_network_layer(&r.info);	/* pass packet to network layer */
                        inc(frame_expected);	/* advance lower edge of receiver's window */
                 }
  
                 /* Ack n implies n - 1, n - 2, etc.  Check for this. */
                while (between(ack_expected, r.ack, next_frame_to_send)) {
                        /* Handle piggybacked ack. */
                        nbuffered = nbuffered - 1;	/* one frame fewer buffered */
                        stop_timer(ack_expected);	/* frame arrived intact; stop timer */
                        inc(ack_expected);	/* contract sender's window */
                }                
                break;

        case cksum_err: ;	/* just ignore bad frames */
                break;
  
        case timeout:	/* trouble; retransmit all outstanding frames */
                next_frame_to_send = ack_expected;	/* start retransmitting here */
                for (i = 1; i <= nbuffered; i++) {
                        send_data(next_frame_to_send, frame_expected, buffer);	/* resend 1 frame */
                        inc(next_frame_to_send);	/* prepare to send the next one */
                }
                break;
     }
  
     if (nbuffered < MAX_SEQ)
        enable_network_layer(); 
     else
        disable_network_layer();
  }
}
```