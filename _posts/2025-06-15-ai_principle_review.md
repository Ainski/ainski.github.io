---
layout: post
title: "人工智能原理与设计复习大纲"
date:   2025-06-15
tags: [学校课程复习,人工智能]
comments: true
toc: true
author: Ainski
---

# 人工智能原理与设计复习大纲
任课老师：Wu     
在本文档当中，将会记录复习中产生的所有文字资料

---
<!-- more -->
## 模块一：人工智能发展历史

### 证明算术公理的相容性
- 完备性：
- 一致性：一个命题不可能同时为真或者假
- 可判定性： 算法在有限步内可以判定命题的真伪

### 人工智能的研究领域

- 以符号主义为核心的 *逻辑推理*
- 以问题求解为核心的 *探寻搜索*
- 以数据驱动为核心的 *机器学习*
- 以行为主义为核心的 *强化学习*
- 以博弈对抗为核心的 *决策智能*

## 模块二：知识表达与推理——确定性知识表示与推理
### 命题逻辑
- `命题` 确定为真或者假的陈述句
- `复合命题` 包含其他命题作为其组成部分的命题，在这个命题当中包含了
    - and
    - or
    - not
    - conditional(逻辑蕴含)
    - bi-conditional (等价)
- 等价使用 `≡` 来表示
### 谓词逻辑
- $\forall \ \exists $ etc 这部分和离散数学重合很多

### 归结原理 
（重要，来自于离散数学2.3内容，当时课堂不讲）

- ***消蕴含和等价***: $ P \to Q = \neg P \vee Q $ 以及等价 $\leftrightarrow$
- ***否定内移***: 将最外面的符号移动到命题上
- ***变量标准化***：每个量词采用不同的变量 $(\forall x)P(x)=(\forall y) P(y)$
- ***消去存在量词***: 如果不在任何一个全称量词的辖域内$ (\exists x)P(x) \Rightarrow P(A) $ 否则，考虑使用skolem 函数表示依赖关系$\forall x\exists y P(x) \vee Q(y) \to \forall x P(x) \vee Q(F(x))$
- ***公式化为前束形*** 把所有的全称量词移动到公式的左边，并使每个量词的辖域包含这个量词后面的整个部分
- ***化为合取范式***
- ***略去全称量词***
- ***消去 $\wedge$*** 把母式用子句集表示
- ***字句变量标准化*** 要求每个字句中的变量符号不同

### 置换和合一
在子句集当中，
$P(x,y) \Leftrightarrow P(w,z)$可以进行如此置换，置换之后相同称之为 ***匹配*** ，因此可以合一。

### 归结原理
基本原理是所有的字句都是与的关系，因此要求所有的字句同时为真  
在归结之前，应当置换变量使他们包含互补的文字，才可以归结例如：
S={P(x) or Q(x) , not P(A) or R(y)}
S={P(x) or Q(x) , not P(x) or R(y)}
归结为 Q(x) or R(y)

***不能同时消去两个互补文字对***

归结原理的使用具体更可以参照离散数学当中的自然推理系统 

### 谓词解决实际问题
步骤如下：定义谓词，谓词公式说明（从题目当中找规则），生成子句集，归结原理归结


## 模块二：知识表达与推理——不确定性知识表达与推理

### 需要掌握的基本知识点

随机变量 基本命题 复合命题 概率分布 先验概率 联合概率分布 完全联合概率分布 条件概率 后验概率    
#### 乘法法则
$P(A \vee B) = P(A | B)P(B) =P(B|A)P(A)$   
#### 链式法则
$P(X_1,X_2...X_n)=\prod_{1}^{n} P(X_i|X_0X_1...X_{i-1})$

条件概率...详细参考上个学期概率论的内容 

#### 归一化方法 
将某一条件下的概率调整其和为1   
其实际运算过程与按照条件概率定义求值的过程基本一样

### 贝叶斯规则
$P(b|a)=\frac{P(a|b)P(b)}{P(a)}$    
这是一个知三求一的式子

### 贝叶斯网络

- 是一个有向无环图
- 表示变量之间的依赖关系
- 本质上，表示任何完全联合概率分布

某一事件发生的概率需要由它的父节点的概率求得    

#### 构建贝叶斯网络的方法

- 以任意次序排序
- 对于每个新加入图的节点，利用独立性检验找到最小父节点

## 搜索探寻与问题求解 —— 搜索树的构建与启发式搜索
这一部分的内容与算法后面的回溯算高度相似，可以参考使用

### 搜索的形式化描述
<状态，动作，状态转移，路径/代价，目标测试>     
< statement,action,transaction,cost,test >
- 状态 智能体当前的状态 s 
- 动作 从一个状态转移到另一个状态所采取的行为 a
- 状态转移 计算转移后的状态的函数 f(s,a) return s'
- 路径/代价 完成动作所需要的消耗 c(s,a,s')
- 目标测试 判定当前状态是否为目标状态 r(s)
### 搜索树
参考算法当中的解空间，两者有相同的定义。    
具体来讲，搜索树指的是从初始状态开始，以树状图的形式将所有的解罗列出来的方式。  
这种方式以偶某种弊端，要求遍历所有的解，因此时间复杂度在 **指数** 等级上    
而遍历的方法为广度为优先队列。

### 启发式搜索

#### 搜索方向
- 数据驱动 正向搜索，从初始状态出发
- 目的驱动 你想搜索，从想要达到的目的入手，看那些操作算子能产生该目的
- 双向搜索 从开始状态出发做正向搜索，也同时从目的状态出发做逆向搜索，直到两条路径在中间的某处交汇为止。

#### 无信息搜索

- 盲目搜索 简单可以解释为 c(s,a,s')=c 即无法判断某个状态消耗更多 通过暴力遍历图中的所有节点
- 包括宽度优先，深度优先，以及一致代价搜索（纯贪心，哪里的从c(s,a,s') 小就走哪里）

#### 评价函数
从原有的f(n) =g ( n)（一致代价搜索） 更新为f(n) = g(n) + h(n)（启发式搜索）
- g(n) = c(s,a,s') 实际代价，即从初始状态到当前状态的实际代价
- h(n) 启发式估计，即从当前状态到目标状态的估计代价

##### 贪婪最佳优先搜索
f(n) = h(n) 目的性极强的算法    

###### 性能
完备性？ x 会陷入死循环
最优性？ x 可能不一定是最优解
时间复杂度？ O(b^m) 一个好的启发函数可以有效降低复杂度
空间复杂度？ O(b^m) 存储搜索树

##### A*搜索
f(n)= h(n)+g(n) 

###### 可容性
如果对于每个节点n h(n)<= h*(n) 那么就是可采纳的 -> 这个版本的搜索树是最优的

###### 一致性
h(n) <= c(n,a,n')+h(n') 即f(n')>=f(n) f(n) 是递减的，因此会有一致性

## 搜索探寻与问题求解 —— 对抗搜索

### 博弈论
- player 参与博弈的决策主体
- strategy 参与者可以采取的行动方案
- strategy set 可以采取的策略集合
    - 混合策略 根据一定的概率分布
    - 纯策略 每次行动选择某个特定的策略
- outcome 采取行动之后形成的状态为 **局势**
- payoff 期望收益

### 题目类型
- 合作博弈
- 非合作博弈

- 静态博弈
- 动态博弈

- 完全信息
- 不完全信息

#### 本章主要讨论 双人轮流式的对弈，两人得到的信息是完备的，零和博弈（只能对一方有利）

### 变量定义
- S0 初始状态
- Player(s) 定义这个时候该谁行动
- Actions(s) 定义此状态下的合法移动集合
- Result(s,a) **转移模型** 定义行动的结果
- Terminal-Test(s) **终止测试**
- Utility(s,p) **效用函数** 在终止状态下的结果

### 博弈树
解空间

### minmax 算法

基本策略： 最大化自身利益，最小化对手的利益
#### 静态估计函数 f
有利于max的状态 f(p)>0 否则 f(p) <0

例如在井字棋当中，可以定义f(p) 为所有空格都放上max 的棋子之后，三字成线的总数减去 所有空格都放上min 的棋子之后，三字成线的总数

### 性能
- 完备性 v
- 最优性 v
- 时间复杂度 O(b^m)
- 空间复杂度 O(b^m)

### Alpha-Beta 算法

基本策略： 把博弈树生成和倒推估值结合起来进行，再根据一定的条件判定，有可能尽早修剪掉一些无用的分枝

在一边计算的过程当中，顺便估计父节点的取值范围，以此减少计算次数。

### Alpha-Beta剪枝算法完整实例演示（修正版）

让我们重新梳理整个Alpha-Beta剪枝过程，确保逻辑准确无误。以下是一个完整的三层博弈树示例，包含详细的搜索步骤和剪枝逻辑：


#### **博弈树结构与节点估值**
```
          A(根节点, Max)
        /      \
       B(Min)   C(Min)
     /   \    /   \
    D(Max) E(Max) F(Max) G(Max)
   / \   / \   / \   / \
  3  5  6  2  1  8  4  7  （叶子节点估值）
```


##### **Alpha-Beta剪枝详细过程**

###### **第一步：搜索左子树（节点B及其子节点）**
1. **节点D（Max）**  
   - 子节点值：3和5  
   - Max节点选择最大值：**5**  
   - 更新α=5（当前Max节点能确保的最小值）  

2. **节点E（Max）**  
   - 子节点值：6和2  
   - Max节点选择最大值：**6**  
   - 更新α=6（因为6 > 5）  

3. **节点B（Min）**  
   - 子节点D=5，E=6  
   - Min节点选择最小值：**5**  
   - 更新β=5（当前Min节点能接受的最大值）  


###### **第二步：搜索右子树（节点C及其子节点）**
1. **节点F（Max）**  
   - 子节点值：1和8  
   - Max节点选择最大值：**8**  
   - 由于8 > 当前α=5，更新α=8  

2. **节点G（Max）**  
   - 子节点值：4和7  
   - Max节点选择最大值：**7**  
   - 由于7 < 当前α=8，α保持不变（α=8）  

3. **节点C（Min）**  
   - 子节点F=8，G=7  
   - Min节点选择最小值：**7**  
   - 更新β=7（当前Min节点能接受的最大值）  


###### **第三步：根节点A的决策**
- 根节点A为Max节点，比较左右子节点：  
  - 左子树B返回值：**5**  
  - 右子树C返回值：**7**  
- Max节点选择最大值：**7**  


###### **剪枝发生的位置**
1. **节点B的剪枝**  
   - 当搜索到节点E时，E的最大值为6。由于B是Min节点且已找到D=5，B的最终值不可能超过5（β=5）。因此，**E的右子树（值2）被剪枝**，无需评估。


###### **可视化剪枝结果**
```
          A(Max, 7)
        /      \
       B(Min,5) C(Min,7)
     /   \    /   \
    D(5)  E(6) F(8) G(7)
   / \   /    / \  / \
  3  5  6    1  8 4   7 （虚线表示被剪枝的分支）
```


###### **关键结论**
1. **最优决策路径**：A → C → G  
2. **最终得分**：7  
3. **剪枝效率**：减少了1个节点的评估（原本需评估8个，实际评估7个）  
4. **核心逻辑验证**：  
   - Min节点始终选择子节点的最小值  
   - Max节点始终选择子节点的最大值  
   - 剪枝条件：当α ≥ β时，停止搜索当前分支  

### 不完美的实施决策
- 加权线性评价函数
    - 通过机器学习来完成对于评价函数权值的估计


## 机器学习

### 概念

- 建立能够刻画数据中蕴含语义概念或分布结构等信息的模型

### 损失函数
- 0-1损失函数 $L(y,f(x_i))=0,1$ 
- 平方损失函数 $L(y,f(x_i))=(y-f(x_i))^2$ 
- 绝对损失函数 $L(y,f(x_i))=|y-f(x_i)|$ 
- 对数损失函数 $L(y,P(y_i|x_i))=-\log(P(y_i|x_i))$ 

### 经验风险与期望风险
- 经验风险 $R=\frac{1}{N}\sum_{i=1}^N L(y_i,f(x_i))$ 

- 期望风险 $R=\int_{x \times y}L(y,f(x))P(x)dx$ 

机器学习一般目标为经验风险最小化，但因为不能获取所有的数据分布。虽然机器学习的目标是追求期望风险最小化。

$\mathfrak{R}\leq\mathfrak{R}_{\text{emp}}+err$ 同一批数据反复训练会导致模型变得复杂，err取值会增大，$\mathfrak{R}$ 增加，称之为过学习

### 泛化能力
指的是模型在训练集上所取得性能与在测试集上所取得性能保持一致。

### 正则化与惩罚项

$ \frac{1}{n}\sum_{i=1}^n L(y_i,f(x_i))+\lambda J(f) $

所有损害优化的方法都是正则化

### 模型度量方法

以二分类问题为例，分别统计正例和反例的样例数目

- 准确率（accuracy）：$acc=\frac{TP+TN}{P+N}$ 所有的正确预测
- 错误率 （Error Rate）：$errrate=\frac{FP}{P+N}$ 所有的错误预测
- 精确率（precision）：$precision=\frac{TP}{TP+FP}$ 所有的正向样例当中的正确预测
- 召回率（Recall）：$recall=\frac{TP}{TP+FN}$ 所有预测为正例的样例当中的正确预测
- 由于精确率与召回率相互矛盾，因此有 F1-score 度量方法：$F1=\frac{2\times precision\times recall}{precision+recall}$  为两者的调和平均数

### 参数优化

- 频率学派 MLE 使观测数据发生概率最大
- 贝叶斯学派 MAP 使似然概率与先验概率乘积最大

## 有监督学习

学习输入与输出之间的映射，典型任务包括分类和回归

一般选择一部分数据作为训练集，将训练集中的一部分数据作为验证集，最后在测试集上进行测试

### 回归分析

分析不同变量之间存在的关系    
按照涉及变量的多少：一元回归，多元回归    
按照自变量和因变量之间的关系，分为线性回归和非线性回归

### 线性回归

#### 一元线性回归
1. 回归方程：$y=b+ax $

2. 最小二乘法 ：使得残差平方和最小的线性方程 $ L(a,b)=\sum_{i=1}^n(y_i-b-ax_i)^2 $ 分别对a和b求偏导，得到最小值

$ a= \frac{\sum_{i=1}^n(x_i- \overline{x})(y_i-\overline{y})}{\sum_{i=1}^n(x_i-\overline{x})^2} = \frac{\sum_{i=1}^n x_iy_i-\sum_{i=1}^n x_i\sum_{i=1}^n y_i}{\sum_{i=1}^n x_i^2-\frac{1}{n}\sum_{i=1}^n x_i^2} $

$ b= \overline{y}-a\overline{x} $

#### 多元线性回归
有数据集大小为m 数据特征纬度为D
$f(x_i)= a_0+\sum_{j=1}^D a_jx_{i,j}=a_0 + a^T x_i $  
最小化均方误差函数：$J_m=\frac{1}{m}\sum_{i=1}^m(y_i-f(x_i))^2$  

#### 多元非线性回归
logistic 回归 采用sigmoid函数 解决二分类问题， 或者采用softmax函数解决多分类问题

### 决策树

将一组训练数据当中学习到的函数表示为一棵树   
每个节点为一个分类实例

#### 建立决策树的过程
- 选择属性值
- 根据属性值对样本集进行划分
- 选择下一个属性值
- 直到每个子集为同一个类别

顺序：越往下信息熵逐渐减小   
信息熵：信息熵越大，集合的不确定度越大，信息熵的减少量越大，信息增益越大

#### 构建决策输的过程
##### 计算信息熵
有K个信息，组成了集合样本D。记第k个信息发生的概率为$p_k(1\leq k \leq K)$，则信息熵为：

$E(D)=-\sum_{k=1}^K p_k\log_2p_k$ p_k 是目标信息发生的概率


##### 计算信息增益
信息增益是指在已知目标信息的情况下，使得样本集合的信息熵减少的程度。

$Gain(D,A)=E(D)-\sum_{v\in A} \frac{|D^v|}{|D|}E(D^v)$   
即按照A属性划分以后，对于目标信息的信息熵

**不可以用编号作为划分属性**

##### 增益率

$GainRatio(D,A)=\frac{Gain(D,A)}{IV(A)}$   
IV(A)是A属性的熵,$IV(A)=-\sum_{v\in A} \frac{|D^v|}{|D|}\log_2\frac{|D^v|}{|D|}$

##### 基尼指数

$Gini(D)=\sum_{k=1}^K \sum_{k'\neq k}p_kp_{k'}=1-\sum_{k=1}^K p_k^2$    
反映了从D中随机抽取两个样本，其类别标记不一致的概率。  
使划分后基尼指数最小的属性作为最优划分属性


## 无监督学习

### 基本概念

希望学习出一些有用的模式，没有标签也没有目标

#### 常见的无监督学习算法

- 聚类 常用的相似度计算方法包括**欧氏距离法** ，常用算法包括 K-means 算法 DBSCN 算法 层次聚类
- 降维 将高位数据映射到低维空间 常见算法有线性判别分析、主成分分析

### 聚类算法
基本概念：同一类别内的对象相似度较高，不同类别之间的相似度较低

#### K-means 算法

基本概念:找到了局部最优解，易受初值影响的迭代算法，因此重复几次以找到局部最优

1. 随机选择 K 个初始质心
2. 产生了k个聚类集合之后，以这些质心为特征值，将每个数据放到距离最近的质心当中
3. 重新计算质心为聚类当中所有数据位置的均值
4. 重复2、3步，直到质心不再移动或者到达规定次数上限

缺点：易受异常值影响   
目标函数： 使得每个类当中的方差最小，即欧氏距离之和最小，同时类间距离较大

### 特征降维—— 线性判别分析

线性判别分析—— LDA是一种基于监督学习的降维方法。 将一组具有标签信息的高位数据样本线性投影到一个低维空间上。    
$\bf m_i$ 为第i类样本的均值向量   
均方差矩阵：$\bf \Sigma =\sum_{i=1}^m(\bf x_i-\bf m_i)(\bf x_i-\bf m_i)^T$   
$||m_i-m_j||^2$ 为类间距离   

$y=w^T\bf(x)+b$  其中$w$是投影方向，$x$是样本，$b$是偏移量   
投影之后的协方差矩阵为 $s_1=\sum_{\bf x \in C_1}(\bf w^T\bf x-\bf w^T\bf m_1)^2=\bf w^T\bf \Sigma_1\bf w$   
##### 优化目标
$ J(\bf w)=\frac{||m_2-m_1||^2}{s_1+s_2}$

##### 算法步骤
1. 计算类间散度矩阵 $\bf S_w $
2. 计算类内散度矩阵 $\bf S_b $
3. 计算矩阵$\bf S_w^{-1}S_b$
4. 计算投影方向 $\bf w $
5. 对样本集中的每一个xi 转化为新的样本
6. 计算偏移量 $b $

### 主成分分析

特征降维方法，找到数据特征的主要成分代替原始数据

1. 对于每个样本$x_i$ 进行去中心化处理 $x_i-\mu ,\mu=\frac{1}{m}\sum_{i=1}^mx_i$
2. 计算协方差矩阵 $\Sigma=\frac{1}{m}\bf X^T\bf X$
3. 对协方差矩阵进行特征值分解，对特征值进行排序，选取前k个最大的特征值对应的特征向量
4. 选取前k个最大的特征向量组成映射矩阵 $\bf W$

### 演化算法

1. 初始化若干规模数目的群体。当前进化代数G=0
2. 计算每个群体的染色体适应值，找到最好的染色体best
3. 随机选择染色体产生同样规模的种群
4. 按照概率对染色体进行交叉互换，交叉产生的染色体进入新种群，为交叉的复制进入新种群
5. 按照概率对染色体的若干基因片段进行变异操作，进入新种群
6. 计算新的适应值，如果适应值提升，那么取代原有的最好的染色体best
7. 重复步骤2-6，直到达到误差要求或达到最大进化代数

## 神经网络与深度学习

### 概述
#### 神经网络-ANN
人工智能网络是由具有适应性的简单单元组成的广泛并行互联的网络，他的组织能够模拟生物神经系统对真实世界物体所作出的反应。
#### 前馈神经网络
前馈神经网络由输入层，输出层，和若干隐藏层构成。
#### 激活函数
sigmoid 激活函数：$f(x)=\frac{1}{1+e^{-x}}$   
  - 可视为概率值输出，单调递增，非线性变化
  - 缺点容易出现梯度消失的问题，计算复杂度高  
  
tanh 激活函数：$f(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}$   
relu 激活函数：$f(x)=max(0,x)$   
- 不会出现梯度消失，梯度饱和的问题，计算复杂度低
- x<0时，输出为0，神经元死亡，防止出现过拟合现象
- 缺点是不稳定，易出现“dying ReLU”现象，即某些神经元死亡，导致网络性能下降  
- 隐藏层常用
Leaky ReLU 激活函数：$f(x)=max(\epsilon x,x)$   
softmax 激活函数：$f(x_i)=\frac{e^{x_i}}{\sum_{j=1}^K e^{x_j}}$   
- 多分类问题常用

### 神经网络参数优化 （监督学习） 
根据梯度下降算法对神经网络中的参数进行更新，模型预测所得的$\hat{y}$与真实$y$之间的误差逐渐缩小。

#### 损失函数
用于计算模型预测值与真实值之间的误差。   
均方误差损失函数 $MSE=(y-\hat{y})^2$   
交叉熵损失函数 $H(y_i,\hat{y_i})=-y_i\log(\hat{y_i})$   
  $ L=-\frac{1}{N}\sum_{i=1}^N\sum_{c=1}^K y_{ic}\log(\hat{y}_{ic})$   

#### 梯度下降算法

1. 初始化w
2. 重复
   1. 计算梯度 $\frac{\partial L}{\partial w}$
   2. 更新参数 $w=w-\eta\frac{\partial L}{\partial w}$

#### 误差反向传播
$
  \frac{\partial L}{\partial w_j} =
  \frac{d L}{d \mathcal{O}} \frac{d \mathcal{O}}{d \mathcal{X}}\frac{d \mathcal{X}}{d w_j}
$   
其中，$\frac{d L}{d \mathcal{O}}$ 与损失函数有关 ，$\frac{d \mathcal{O}}{d \mathcal{X}}$ 是对激活函数求导，
$\frac{d \mathcal{X}}{d w_j}$ 是对权重矩阵求导。   
$\eta$ 学习率

#### 梯度下降的方法

1. 批量梯度下降：每次更新所有样本的梯度
2. 小批量梯度下降：每次更新一小部分样本的梯度
3. 随机梯度下降：每次更新一个样本的梯度

#### 误差反向传播算法

1. 初始化
2. 提供训练模式，将模式和期望输出送入网络
3. 计算网络的输出模式与期望比较，如有误差，那么反向传播
4. 直到满足训练结束条件为止

### 卷积神经网络
#### 概论
前馈神经网络，局部连接，权重共享，空间或者时间上的次采样
##### 池化
- 最大池化 选择最大值
- 平均池化 选择平均值
- k-max池化 选择k个最大值

### 循环神经网络
#### 概念
Recurrent Neural Network (RNN) 循环神经网络. 隐含编码$h_{t-1}$ 已经记忆了t时刻之前的时序信息   
$h_t=f(\bf W h_{t-1}+\bf U x_t)$   
$f$ 是非线性激活函数，$x_t$ 是输入，$h_t$ 是输出   
#### 训练方法
- BPTT 随时间反向传播
#### 长短时记忆模型（LSTM）
- 引入内部记忆单元，门结构。
  - 输入门 LSTM控制有多少单元状态$c_t$ 输出
  - 遗忘门 决定了上个时刻的单元状态$c_t$有多少被保留到当前时刻
  - 输出门 决定了当前时刻网络的输入$x_t$ 有多少被保存到单元状态$c_t$中

#### 门控循环神经单元（GRU）
- 引入重置门，更新门，来控制单元状态的更新
- 重置门 前一状态有多少信息被写入，门越小写入越少 输入门和输入门被合并
- 更新门 控制前一时刻有多少信息被写入 

### 注意力机制与正则化
注意力机制可以分为两步
1. 计算注意力分布  
  $\alpha_n=p(z=n|\bf X,\bf q)=softmax(s(\bf x_n ,\bf q))$  
  s是打分函数    
  $ att(\bf X,\bf q)=\sum_{n=1}^N\alpha_n\bf x_n $
2. 根据$\alpha$ 来计算输入信息的加权平均



正则化方法：
把每层中任意神经元的输入值分布改为均值为0，方差为1的正态分布。

### 强化学习

#### 概念
智能体通过采取不同的动作与环境之间交互，学会在不确定环境中进行决策    
智能体在环境下不断试错，以最大化回报为驱动力，在试错过程中逐渐适应环境，达成学习的目的。

##### 二部分，三要素
- 智能体：学习者和决策者
- 环境：环境是智能体与外界交互的场所，包括状态和动作
- 奖励：奖励是智能体在环境中获得的奖励
- 状态：智能体在环境中所处的状态
- 动作：智能体在环境中采取的动作
- 策略：执行某个动作的一句
- 模型：将状态-动作映射到状态的概率分布
- 价值函数：从该状态出发并执行特定策略所获得的长期回报

#### 离散马尔科夫链
- 随机过程：一系列随时间变化的随机变量
- 马尔科夫链：t+1时刻的状态仅仅依赖于t时刻的状态，不依赖于t+1时刻之前的状态
##### 引入奖励机制
- 奖励: $R:S \times S \rightarrow \mathbb{R}$   
- 回报: $G_t=R(s_t,a_t)+\gamma R(s_{t+1},a_{t+1})+\gamma^2 R(s_{t+2},a_{t+2})+\cdots$   

- 马尔科夫模型MP=(S,P)
- 马尔科夫奖励过程MRP=(S,P,R,$\gamma$)

##### 马尔科夫决策过程
- 状态集合S: 所有可能的状态    
- 动作集合A: 所有可能的动作   
- 状态转移概率 $P(s_{t+1}|s_t,a_t)$    
- 奖励函数 $R(s_t,a_t,s_{t+1})$    
- 折扣因子 $\gamma$    

#### 强化学习定义
- 策略函数：$\pi:S \times A \rightarrow [0,1]$ 表示在状态s下执行动作a的概率   
- 价值函数：$V_{\pi}(s)=\mathbb E_{\pi} [G_t|s_t=s] $  指的是时刻t，状态s下，策略$\pi$下，累计奖励的期望值。   
- 动作-价值函数： $q_{\pi}(s,a)=\mathbb E_{\pi} [G_t|s_t=s,a_t=a]$ t,s下选择x的期望   
- 学习一个最优策略$\pi^*$，使得任意一个$s \in S$下，$V_{\pi^*}(s)$最大。

##### 贝尔曼方程
- 价值函数：$V_{\pi}(s)=\mathbb E_{\pi}[R_{t}+\gamma R_{t+1}+\gamma^2 R_{t+2}+\cdots|s_t=s]$   
 $V=E(R+\gamma V)$  下一时刻每一个状态下采取每一个动作的回报 v=E(q)
- 动作价值函数 $q_{\pi}(s,a)=\mathbb E_{\pi}[R_{t}+\gamma R_{t+1}+\gamma^2 R_{t+2}+\cdots|s_t=s,a_t=a]$  
 $q=E(R+ \gamma V)$

求解最优策略的方法求最优的价值函数或者动作价值函数

在强化学习中还有基于策略和基于模型等不同方法

#### 基于价值的强化学习
通过策略计算价值函数的 过程叫做策略评估，通过贾占函数优化策略的过程家做过策略优化，两者交错进行叫做策略迭代

策略优化定理： 如果价值函数更好，那么策略更优

##### 策略评估

蒙特卡洛采样：从状态s不断向后采用，得到不同的采样序列，这些状态序列的平均值作为s的回报值
##### 时序差分
价值函数 $V=(1-\alpha)V(s)+\alpha (R(s,a,s')+\gamma V(s'))$   
##### q_table 
只维护q函数