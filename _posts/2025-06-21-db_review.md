---
layout: post
title: "数据库系统原理复习大纲"
date:   2025-06-19
tags: [学校课程复习,数据库]
comments: true
toc: true
author: Ainski
---

任课老师:Li  
请注意，本文档的结构来自于老师提供的复习PPT

---
<!-- more -->
## 第一章 数据库系统概述

### 传统文件处理系统的缺点
- 数据的冗余和不一致性
- 数据访问困难
- 数据鼓励
- 完整性问题
- 原子性问题
- 并发访问异常
- 安全性问题

### 数据库定义
- 一组相互关联的有组织的可管理的可共享的数据集合
基本特征：按照一定的数据模型组织描述和存储，支持增删改查，支持并发查询处理
### DBMS
- 用户与操作系统之间的数据库管理软件
- 一个管理数据的大型复杂基础软件系统
### 数据抽象的层次
- 物理层：描述数据实际上是怎样存储的
- 逻辑层：描述数据之间的关系
- 视图层：提供一种抽象的机制，使得用户可以看到所需的数据

## 第二章 关系模型
### 数据模型与数据库模式
用户需求 --> 概念模型 --> 逻辑模型 --> 物理模型  
### 关系模式 Relational schema
### 关系 relation
表
### 关系实例 relation instance
一个关系特定的行
### 元组 tuple
一个行
### 属性 attibute
列
### 超码 superkey
一个或者多个属性的集合，能够唯一标识一个元组
### 候选码 candidate key
一个超码，任何真子集都不是超码
### 主码 primary key
被设计者选中作为区分不同数据库主要方式的候选码
### 外码 foreign key
一个关系中指向另一个关系的属性
### 查询语言 query language, procedural language, non-procedural language
query language: SQL, DML, DDL  
procedural language: PL/SQL, Java  
non-procedural language: C, C++, Python, JavaScript  
函数式查询语言，声明式查询语言，命令式查询语言
### 关系代数 
#### 选择 select
$\sigma_{A}(R)$ 选择满足条件A的元组  
例如 $\sigma_{age>20}(student)$ 选择年龄大于20的学生  
#### 投影 project
$\Pi_{A}(R)$ 投影出属性A的元组  
例如 $\Pi_{name,age}(student)$ 投影出学生的姓名和年龄  
#### 重名 rename
$\rho_{A}(R)$ 重命名属性R为A    
$\rho_{A(x_1,x_2,x_3 \dots)}(R)$ 将R重命名为A，同时重命名R的属性为$x_1 ,x_2 ,x_3 \dots$

#### 笛卡尔积 catesian product
$R \times S$ 所有元组的笛卡尔积  
例如 $student \times course$ 学生和课程的笛卡尔积，运算之后有两者大小乘积个元组  
#### 链接 
$\sigma_{A}(R \times S)$ 选择满足条件A的元组  
例如 $\sigma_{age>20}(student \times course)  
亦可写作$R \bowtie_{A} S$ 表示$R \times S$的子集，满足条件A的元组  
例如 $student \bowtie_{age>20} course$ 学生和课程的交集，满足年龄大于20的元组  

#### 自然连接 natural join
$R \bowtie S$ 所有元组的自然连接  $t_r$和$t_s$ 具有相同的属性和值
#### 赋值 assignment
相当于定义变量的过程 
A <- B 表示将A定义为B运算结果的值
#### 广义投影 generalized projection
$\Pi_{x-y}(R)$ 允许做运算   
例如 $\Pi_{age-name}(student)$ 投影出学生的年龄和姓名  
#### 并集 union
$R \cup S$ 所有元组的并集  
例如 $\sigma_{age>20}(student) \cup \sigma_{age<10}(student)$ 所有年龄大于20或者年龄小于10的学生  

#### 集差 set difference 
$R - S$ 所有元组在R中但不在S中的元组  
例如 $\sigma_{age>20}(student) - \sigma_{age>100}(student)$  年龄大于20但年龄不大于100的学生  
#### 集合交 intersection
$R \cap S$ 所有元组的交集  
例如 $\sigma_{age>20}(student) \cap \sigma_{age<10}(student)$ 所有年龄大于20并且年龄小于10的学生  
#### 外连接 outer join
$A \Join = B$ 表示保留A的所有属性，在B中没有匹配的元组，用NULL填充  
#### 除 division
$R \div S = \{t|t \in \Pi_{r-s 表示只有R有的属性}(R) \wedge \forall u \in S ,tu \in R\}$ 
#### 聚集函数 aggregate functions
f(A) 表示对A属性的值取平均值
- avg
- min
- max
- count
- sum
#### 空值 null values
表示值未知或不存在
#### 删除 deletion
#### 插入 insertion
#### 更新 updating
#### 视图 view

## 第三，四，五章 SQL
### DDL
定义关系及其相关信息，包括：
- 关系的模式
- 属性的域
- 完整性约束
- 索引结构
- 安全性和权限信息
- 物理存储结构
### DDM

### 主要数据类型 Domain types
- char(n) 定长字符串
- varchar(n) 变长字符串
- int 整数
- smallint 短整数
- numeric(p,s) 定点数 p是位数，s是小数点后位数
- real double preicision 双精度浮点数
- float 单精度浮点数
- null value 允许所有的类型
### 创建语言 Create table construct
```sql
CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    ...
);
```
完整性约束：
- not null
- primary key (A1,A2,...)
- foreign key (A1,A2,...) references table_name(A1,A2,...)
- check (expression)
- unique 
- default value
### 删除或修改
```sql
drop table table_name;
```
表示从数据库中删除这个表

---
```sql
alter table r add A D constraint;
```
表示在关系r中增加一个属性A，数据类型为D，约束为constraint

---
```sql
alter table r drop A;
```
表示在关系r中删除属性A

---
### 数据库操作
#### select
基本查询结构：
```sql
select A1,A2...
from r1,r2...
where P
```
表示$\Pi_{A1,A2...}(\sigma_{P}(R_1 \times R_2 \times \cdots))$
##### select distinct/all 字句
- distinct 去除/保留重复的元组
``` sql
select [distinct/all] A1,A2...
from r1,r2...
```
##### where between and in 字句
- between A and B 选择A到B之间的元组
```sql
select A1,A2...
from r1,r2...
where A between B and C
```
#### join 
- natural join
``` sql
select A1,A2...
from r1 natural join r2
```
- join using 
``` sql
select A1,A2...
from r1 join r2 using (A)
```
#### rename
```sql
select customer_name.borrower.loan_number as loan_id,amount
from borrower,loan 
```
- inner join
```sql
select A1,A2...
from A inner join B on P
```
- left/right outer join
- full outer join
---
注意：natural 和using去重复，on不会
#### 字符串运算
- like ‘%’ 通配符可以匹配任意长度字符串
- like ‘_’ 通配符可以匹配任意单个字符
- 转义字符:
  - '\\' \
  - '\%' %
  - '\_' _
  - 此外支持以ascii码进行访问，例如char(34) 表示双引号
例如
```sql
building like '%Waston%'
```
#### ordering of tuples 排序
形式具体表现为：
```sql
select A1,A2...
from r1,r2...
where p
order by A1 [asc/desc],A2 [asc/desc]...
```
其中order by 按照先后顺序进行排序，asc表示升序，desc表示降序
#### set operations  集合运算
```sql
(select ...) union (select ...)
(select ...) intersect (select ...)
(select ...) except (select ...)
```
#### null values 空值
```sql
select * from r where A is null
```
特别的，所有的聚集函数当中除了count(*) 都将忽略所有的控制
#### aggregation 聚集函数
- avg
- min
- max
- count
- sum
```sql
select count( distinct ID)
from teachers 
where semester ='Spring' and year =2018
```
- group by 
按照某一属性进行分组
```sql
select avg(age)
from students
group by gender
```
表示对学生的性别进行分组，计算每个性别的平均年龄
- group by having
where 在 形成组之前使用
having 在 形成组之后使用
```sql
select class,avg(age)
from students
group by class having avg(age) > 20
```

#### nested subqueries 嵌套子查询

#### set comparison 集合比较
- 集合包含
```sql
select distinct customer_name
from borrower
where customer_name in (
    select customer_name 
    from depositor
)
```
- some
E \< comp \> some r 表示   
$\exists t \in r,E <comp > t$   
$comp \in \{\lt,\le,\gt,\ge,\neq,=\}$
```sql
select branch_name
from branch
where assets > some(
    select assets
    from branch
    where branch_city='Brooklyn'
)
```
- all
E \< comp \> all r 表示   
$\forall t \in r,E <comp > t$   
```sql
select branch_name
from branch
where assets > all(
    select assets
    from branch where branch_city='Brooklyn'
)
```
- 空关系测试
$ exists r \Leftrightarrow r \neq \emptyset$
$ not exists r \Leftrightarrow r = \emptyset$
```sql
select distinct customer_name
from borrower
where exists (
    select *
    from depositor
    where borrower.customre_name = depositor.customer_name
)
``` 
- 重复元组测试
测试子查询是否用重复元组在查询结果当中  
例如：找到所有的消费者拥有一个银行账户在嘉定支行当中
``` sql
select T.customer_name
from depositor as T
where unique (
    select R.customer_name
    from account,depositor as R
    where T.customer_name = R.customer_name and R.branch_name = 'Jiading'
)
```

#### view 视图
``` sql
CREATE view v as <query expression>;
```
视图的更新：   
一般来说，如果满足以下条件，SQL视图是可更新的：
- `from`子句只有一个关系。
- `select`子句仅包含该关系的属性名，且没有任何表达式、聚合函数或`distinct`指定。
- `select`子句中未列出的任何属性都可以设置为`null`。
- 该查询没有`group by`或`having`子句。 

#### 导出关系 Derived Relations
使用as字句在一个查询当中生明一个新的关系   
例如: 找到最大的银行账户余额总值
``` sql
select max(tot_blance)
from (
    select branch_name,sum(balance)
    from account
    group by branch_name)
    as branch_total(branch_name,tot_blance)
```
#### with 字句
定义作用域在数据库下的子查询作为一个新的关系
```sql
with max_balance (value) as 
    select max(balance)
    from account;
```
#### Deletion 
```sql
delete from r where p;
```
#### Insertion
``` sql
insert into r (A1,A2...) values (v1,v2...);
```
#### Update
```sql
update account 
set balance = balance + 100
where balance <= 10000;
```
- case
```sql
update R
set A =
case 
  when pred1 then result1
  .
  .
  .
  else
end;
```
例如
``` sql
update account 
  set balance =
case 
  when balance <= 10000 
    then balance + 100
    else balance *1.06
end ;
```
### Transactions 事务
事务是作为单个单元执行的查询和更新语句序列。
- 事务会自动启动，并通过以下方式之一终止：
    - commit [work]（提交[工作]）：使事务的所有更新在数据库中永久生效。
    - rollback [work]（回滚[工作]）：撤销事务执行的所有更新。 
### 完整性约束
完整性约束通过确保对数据库的授权更改不会导致数据一致性的丢失，来防止对数据库的意外破坏。
#### 域约束
``` sql
create domain d datatype;
create domain d datatype constraint value_test check (expression);
```
域约束是完整性约束的最基本形式
#### 非空约束
``` sql
not null
```
#### unique
```sql
create table t(
    unique (A1,A2,...)--表示A1,A2...为一个超码
)
``` 
#### check
```sql
check (expression)
```
#### foreign key
```sql
foreign key (dept_name) references deoartment
  on delete cascade/set null/set default
  on update cascade
```
#### assertion 断言
希望数据库总能满足某一个条件
```sql
create assertion a check (expression);
```
### 安全性与权限
#### levels of security 安全级别
从高级到低级，分为:
- Database system level 数据库系统级别
- Operation system level 操作系统级别
- Network level 网络级别
- Physic level
- Human level
#### forms of authorization to modify DB 数据修改权限
``` sql
grant/revoke permission
on view/relation
to role/user
```
$permission \in \{update,insert,delete,select,create table,drop table,alter table\dots \}$


#### Granting privileges ,role  保证数据安全的角色机制
```sql
create role r1;
```
创建一个用户，可以将某个用户授予某种角色，也可以将一个用户像角色一样授权给别人
- 直接执行 GRANT GRANT TO ROLE 会报错，因为 GRANT 本身不是一个可授予的对象权限，而是数据库操作语句。
- 正确做法：若要让角色拥有授权权限，需授予其特定权限的 WITH GRANT OPTION。例如：
```sql
-- 授予角色 `admin_role` 对数据库 `test_db` 中所有表的 SELECT 权限，并允许其授权给其他用户/角色
GRANT SELECT ON test_db.* TO admin_role WITH GRANT OPTION;
```

防止级联收权，u3的权限来自于u2,但是收回u3权限的同时不想收回u2的权限，因此有如下语句
```sql
revoke select on department from user restrict;
```
#### Audit trails encryption authentication 审计跟踪，加密，认证
- 审计跟踪  
审计跟踪是对数据库所有更改（插入/删除/更新）的日志记录，同时包含诸如以下信息：是哪个用户执行了更改，以及何时执行的更改。
  - 用于跟踪错误/欺诈性更新。
  - 可以使用触发器来实现，但许多数据库系统也提供直接支持。 
- 加密
当数据库授权条款无法提供足够保护时，数据可以进行加密。
  良好加密技术的特性：
  - 对于授权用户而言，加密和解密数据相对简单。  
  - 加密方案并不依赖于算法的保密性，而是依赖于算法中一个称为加密密钥（密钥）的参数的保密性。
  - 入侵者极难确定加密密钥。 
### 一些未尽的事务
#### 嵌入式SQL（Embedded SQL）  
**定义**：将SQL语句直接嵌入到宿主编程语言（如C、Java、Python）中的技术，用于实现数据库与应用程序的交互。  
**核心作用**：  
- **融合数据操作与业务逻辑**：在应用代码中直接编写SQL语句，避免数据在应用层与数据库层之间的频繁传输。  
- **示例场景**：在C语言中通过嵌入式SQL查询用户数据：  
  ```c
  EXEC SQL BEGIN DECLARE SECTION;  // 声明宿主变量
  int user_id;
  char username[50];
  EXEC SQL END DECLARE SECTION;
  
  EXEC SQL SELECT username INTO :username FROM users WHERE id = :user_id;
  ```  
- **关键机制**：通过`EXEC SQL`前缀标识SQL语句，使用宿主变量（带冒号前缀）与SQL交互。  


##### 通过游标更新（Update through Cursors）  
**游标（Cursor）**：类似文件指针，用于遍历查询结果集的逐行数据。  
**更新逻辑**：  
1. **声明游标**：绑定查询结果集到游标（如`DECLARE cur CURSOR FOR SELECT * FROM products`）。  
2. **打开游标**：执行查询并定位到首行（`OPEN cur`）。  
3. **遍历与更新**：通过`FETCH`获取当前行，用`UPDATE`修改数据，如：  
   ```sql
   FETCH cur INTO @id, @price;
   UPDATE products SET price = @price * 1.1 WHERE CURRENT OF cur;
   ```  
4. **关闭游标**：释放资源（`CLOSE cur`）。  
**应用场景**：处理需要逐行更新的场景（如库存批量调整、数据校验修正）。  


#### 动态SQL（Dynamic SQL）  
**定义**：在运行时动态拼接或生成SQL语句的技术，区别于静态预定义的SQL。  
**核心特性**：  
- **灵活性**：根据变量或条件动态构造语句，例如：  
  ```sql
  SET @table_name = 'users';
  SET @sql = CONCAT('SELECT * FROM ', @table_name, ' WHERE status = 1');
  PREPARE stmt FROM @sql;
  EXECUTE stmt;
  ```  
- **风险与防护**：  
  - **SQL注入风险**：未过滤用户输入时，可能被恶意拼接语句（如`' OR 1=1 --`）。  
  - **安全方案**：使用参数化查询（如MySQL的`PREPARE`+`EXECUTE`）或ORM框架自动转义。  
- **应用场景**：报表生成（动态指定查询字段）、通用数据接口（根据条件动态拼接WHERE子句）。  


#### 函数与过程构造（Functions and Procedures Constructs）  
##### 存储过程（Stored Procedure）  
- **定义**：预编译并存储在数据库中的SQL语句集合，可接受参数、执行逻辑操作。  
- **示例**：计算用户订单总额：  
  ```sql
  CREATE PROCEDURE calculate_order_total(IN order_id INT, OUT total DECIMAL)
  BEGIN
    SELECT SUM(price * quantity) INTO total FROM order_items WHERE order_id = order_id;
  END;
  ```  
- **优势**：减少网络传输、封装业务逻辑、提升性能（仅首次编译开销）。  

##### 函数（Function）  
- **定义**：类似存储过程，但必须返回单个值，可用于表达式中。  
- **示例**：返回用户等级：  
  ```sql
  CREATE FUNCTION get_user_level(age INT) RETURNS VARCHAR(20)
  BEGIN
    IF age >= 60 THEN RETURN 'Senior';
    ELSEIF age >= 18 THEN RETURN 'Adult';
    ELSE RETURN 'Youth';
    END IF;
  END;
  ```  
- **区别**：函数可在SELECT语句中调用（如`SELECT get_user_level(age) FROM users`），存储过程需单独执行。  


### 递归查询（Recursive Queries）  
**定义**：通过自引用或分层结构查询数据的方法，常用于处理树状或层级关系（如部门架构、家谱、目录结构）。  
**核心语法（以CTE为例）**：  
```sql
WITH RECURSIVE dept_hierarchy AS (
  -- 基础查询：获取顶层部门
  SELECT id, name, parent_id, 1 AS level
  FROM departments
  WHERE parent_id IS NULL
  UNION ALL
  -- 递归查询：关联子部门
  SELECT d.id, d.name, d.parent_id, dh.level + 1
  FROM departments d
  JOIN dept_hierarchy dh ON d.parent_id = dh.id
)
SELECT * FROM dept_hierarchy;
```  
**关键步骤**：  
1. **基础情况**：定义递归起点（如顶层节点）。  
2. **递归情况**：通过JOIN操作向下层扩展，直到无新数据加入。  
**应用场景**：  
- 计算员工汇报层级（如“谁是CEO的直接下属的下属”）。  
- 物料清单（BOM）查询：递归获取产品所有子组件。  


#### 高级SQL特性（Advanced SQL Features）  
##### 1. 窗口函数（Window Functions）  
- **作用**：在不分组的情况下对数据进行分组计算，保留原始行数据。  
- **示例**：计算每个部门的薪资排名：  
  ```sql
  SELECT dept, name, salary,
         RANK() OVER (PARTITION BY dept ORDER BY salary DESC) AS salary_rank
  FROM employees;
  ```  
- **常用函数**：`RANK()`、`DENSE_RANK()`、`ROW_NUMBER()`、`SUM() OVER()`。  

##### 2. 公用表表达式（CTE, Common Table Expression）  
- **作用**：临时定义一个查询结果集，可在主查询中多次引用，类似临时表但更轻量。  
- **示例**：  
  ```sql
  WITH high_salary AS (
    SELECT * FROM employees WHERE salary > 10000
  )
  SELECT dept, COUNT(*) FROM high_salary GROUP BY dept;
  ```  

##### 3. 分区表（Partitioned Tables）  
- **作用**：将大表数据按规则（如时间、地域）分割为多个物理子表，提升查询性能。  
- **示例（MySQL）**：  
  ```sql
  CREATE TABLE sales (
    id INT,
    sale_date DATE,
    amount DECIMAL
  )
  PARTITION BY RANGE(YEAR(sale_date)) (
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN MAXVALUE
  );
  ```  

##### 4. JSON/XML支持  
- **作用**：处理非结构化数据，如JSON字段的查询与解析。  
- **示例（PostgreSQL）**：  
  ```sql
  SELECT data->'name' AS username FROM users WHERE data->'age' > 30;
  ```  

##### 5. 空间数据类型  
- **作用**：存储与查询地理坐标、几何图形（如点、线、面），用于GIS系统。  
- **示例（PostGIS）**：  
  ```sql
  CREATE TABLE locations (
    id INT,
    point GEOMETRY(Point, 4326)
  );
  -- 查询半径5公里内的点
  SELECT * FROM locations WHERE ST_DWithin(point, ST_GeomFromText('POINT(116.4074 39.9042)', 4326), 5000);
  ```  

##### 6. 事务与锁机制  
- **高级特性**：如分布式事务（XA协议）、细粒度锁（行级锁、乐观锁），保障并发数据一致性。  

这些特性使SQL具备处理复杂业务逻辑、大规模数据和非结构化数据的能力，是现代数据库系统的核心竞争力之一。

## 第六章 数据库设计与E-R模型
### 数据库设计
#### 概念层 Conceptual design
#### 逻辑层 Logical design
#### 物理层 Physical design
### 关系集 Relational set
- Degree of mapping cardinality 映射度
### ER图设计
#### entity sets vs attribute sets 实体集与属性集
#### entity sets vs relationship sets 实体集与关系集
#### binary vs n-ary relationships 二元关系与多元关系
#### use of specializations/generalizations 特化与泛化
### Symbols used in E-R diagrams 符号在E-R图中的使用
### Reduction of an E-R diagram to relational tables 简化E-R图为关系表

## 第七章 数据库关系设计
### Functional Dependency 函数依赖
#### closure of functional dependency 函数依赖闭包
##### Armstrong's axiom 阿姆斯特朗公理 
- reflexivity 自反性
- augmentation 增广性
- transitivity 传递性
##### Additional rules
- union 合并
- decomposition 分解
- psedotransitivity 伪传递性
#### Closure of attribute set  属性集的闭包
#### Canonical cover  候选键集
- Extraneous attribute and its testing
#### Find all candidate keys  找到所有的候选键
### Decoomposition 分解
- lossless-join decomposition and dependency preservation 无损连接分解与依赖保持

### Normalization and Normal Forms 规范化与范式
#### 1NF 第一范式
#### 2NF 第二范式
#### 3NF 第三范式
#### BCNF 
#### Testing for BCNF and 3NF 
#### corresponding decompositions and dependencies 相应的分解与依赖

## 第12-13章 Storage and file Stucture 存储与文件结构
### Classification of physical storage media 物理存储介质分类
#### speed cost reliatbility volatile non-volatile 速度成本可靠性 易失性非易失性
#### cache ,main memory, flash ,magnetic disk ,optical storge ,tape  缓存，主存，闪存，磁盘，光盘，光纤存储，磁带
### Perfomance measure and optimization of disk access 磁盘访问性能测量与优化
#### Access time 访问时间 
#### data transfer rate 数据传输速率
#### mean time to failure   平均故障时间
#### Block  
#### disk-arm-scheduling 磁盘臂调度

### Storage and buffer manage 
### 一些未尽的事务
#### File organization  文件组织
- fixed-length records 定长记录
- variable-length records 变长记录
- organization of records in files 文件记录组织
#### Data dictionary stoage  数据字典存储
#### Raid levels 1-6  磁盘阵列级别

## 第14章 Indexing 索引
### 基本概念 索引的是搜索码的值
#### Serch and index file  搜索和索引文件
#### ordered index and hashed index 有序索引和散列索引
#### Primary index and clustering index  主键索引和聚集索引
#### Secondary index or non-clustered index  辅助索引或非聚集索引
#### Dense index 稠密索引
#### Sparse index 稀疏索引
#### multilevel index 多级索引
### Ordered index  有序索引
#### B-tree  B树
#### B+-tree  B+树
### *Hash index 散列索引
#### Static hashing 静态哈希
#### Dynamic hashing:extendable hashing 动态哈希：可扩展哈希
### Ordered indexing vs hashing
### Index definition in sql 索引定义在SQL中的使用
### *Multiple-key access
- grid files and bitmap index 网格文件和位图索引

## 第15章 Query Processing  查询处理
### Basic steps in query processing  查询处理的基本步骤
#### Parsing and translation  解析与翻译
#### Optimization  优化
#### Exaluation  评估
### Measures of query cost  查询成本的度量
#### seek time
#### number of data block transfers  数据块传输的数量
### Selection operation 选择操作
#### File scan vs index scan  文件扫描与索引扫描
#### A1-A10
### Sorting 
- External sorting  外部排序
### Join operation  连接操作
#### Nested loops join  嵌套循环连接
#### Block nested loops join  块嵌套循环连接
#### Indexed nested loops join  索引嵌套循环连接
#### *Merge join  合并连接
#### *Hash join  哈希连接
### Evaluation of expressions   表达式的评估
#### Materialization 物化
#### Pipeline 流水线

## 第16章 查询优化
### Evaluating a given query   给定查询的评估
#### Equivalent expressions :equivalence results 等价表达式：等价结果
#### Different algorithms :performance results 不同的算法：性能结果
### Measures of cost
#### select size
#### join size
#### distinct values
### Evaltuation plan  评估计划
### Practical query optimizers combine the following approaches:
#### search all the plans and choose the best plan in a cost-based fashion :dynamic programming 搜索所有计划并以基于成本的选择最佳计划 :动态规划
#### Use heuristics to choose a good plan 启发式方法选择一个好的计划

## 第17章 transations 事务
### Transaction
#### 定义
#### ACID properties 
- Atomicity 原子性
- Consistency 一致性
- Isolation 隔离性
- Durability 持久性
#### Transaction states 
### Serializability 串行化
#### conflict serializability 冲突串行化
#### view serializability 视图串行化
### Recovery
#### cascade rollback 级联回滚
#### cascadeless schedule 级联不带调度
### test for serializability  测试串行化
#### Precedence graph   先行图

## 第18章 Concurrency Control 并发控制
### Lock-based protocols 基于锁的协议
#### Lock-compatibility martrix 锁兼容矩阵
#### Deadlock and starvation 死锁与饥饿
#### Two phase locking protocol 两阶段锁定协议
##### strict two-phase locking 严格两阶段锁定
##### rigorous two-phase locking   严格两阶段锁定
#### Lock manager and lock table 锁管理器和锁表
#### graph based protocol :impose a partial ordering 基于图的协议：施加部分排序
### *Multiple granularity 多粒度
#### intention lock modes  意图锁模式
#### Compatibility martrix with intention lock modes  意图锁模式的兼容矩阵
### Deadlock handling
#### Deadlock prevention protocols 死锁预防协议
##### graph-based protocols 基于图的协议
##### timestammp-based protocols 基于时间戳的协议
###### schemes use transatction timestamps:wait-die scheme and wound-wait shceme  方案使用事务时间戳：等待-死锁协议和等待-等待协议
###### timeout-based schemes 基于超时的方案
#### Deadlock detecion
- wait-for graph 等待图

## 第19章 Recovery Systems  故障恢复系统
### Shadowing page 
### log based recovery 日志恢复
#### deferred database modification
#### Immediate database modification
#### checkpoints
### Recovery with concurrent transactions  并发事务下的恢复